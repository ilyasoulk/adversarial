[
    {
        "title": "Shape Area Calculator",
        "description": "Write a program to calculate the area of different shapes. Create a base class called Shape with a method called getArea(). Create two subclasses Rectangle and Circle with their respective area calculations. The Rectangle class should take the width and height as arguments and Circle class should take the radius as an argument.",
        "entry_point": "getArea",
        "docstring": "def getArea(shape: Shape) -> float :\n            \"\"\"\n            Calculates the area of the given shape object.\n\n            Parameters:\n                shape: Shape object\n\n            Returns:\n                float: The area of the given shape object.\n            \"\"\"",
        "unit_tests": "# Test for Rectangle shape\ndef test_rectangle_area():\n    length = 5\n    breadth = 6\n    rectangle = Rectangle(length, breadth)\n    assert rectangle.getArea() == (length * breadth)\n\n# Test for Circle shape with radius 5\ndef test_circle_area():\n    radius = 5\n    circle = Circle(radius)\n    assert circle.getArea() == (3.14 * (radius ** 2))\n\n# Test for Circle shape with radius 0\ndef test_circle_area_zero_radius():\n    radius = 0\n    circle = Circle(radius)\n    assert circle.getArea() == 0\n\n# Test for Rectangle shape with width and height both 0\ndef test_rectangle_area_zero_dimensions():\n    width = 0\n    height = 0\n    rectangle = Rectangle(width, height)\n    assert rectangle.getArea() == 0\n\n# Test for Circle shape with negative radius\ndef test_circle_area_negative_radius():\n    radius = -1\n    circle = Circle(radius)\n    assert circle.getArea() is None\n\n# Test for Rectangle shape with negative width and height\ndef test_rectangle_area_negative_dimensions():\n    width = -5\n    height = -6\n    rectangle = Rectangle(width, height)\n    assert rectangle.getArea() is None"
    },
    {
        "title": "Exercise 1 : Merge Two Sorted Lists",
        "description": "Write a function named \"mergeList\" that takes in two lists \"list1\" and \"list2\", both of which are sorted in ascending order, and returns a new list that is the merge of the two input lists. The new list should also be sorted in ascending order. The input lists can be empty, contain duplicates or be of any size.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int] or List[float], list2: List[int] or List[float]) -> List[int] or List[float] :\n\"\"\"\nThis function takes two sorted lists as input and returns a new sorted list which is the merge of the two input lists.\nThe input lists can be empty, contain duplicates or be of any size.\nBoth input lists should be of the same type either int or float.\n\"\"\"",
        "unit_tests": "# Test Case 1: Merge two empty lists\nassert mergeList([] , []) == []\n\n# Test Case 2: Merge two lists with same elements and same order\nassert mergeList([1, 2, 3], [1, 2, 3]) == [1, 2, 3]\n\n# Test Case 3: Merge two lists with same elements but different order\nassert mergeList([1, 2], [2, 1]) == [1, 2]\n\n# Test Case 4: Merge two lists with different elements\nassert mergeList([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]\n\n# Test Case 5: Merge two lists with duplicates\nassert mergeList([1, 2, 3, 3], [4, 4, 4]) == [1, 2, 3, 3, 4, 4, 4]"
    },
    {
        "title": "Exercise 2 : Implement a LRU Cache",
        "description": "Write a class named \"LRUCache\" with a constructor that takes an integer \"capacity\", and methods named \"get\" and \"put\". The \"get\" method takes an integer \"key\" as an argument and returns the value associated with that key. The \"put\" method takes an integer \"key\", an integer or string \"value\", and an optional boolean \"update\" that is set to false by default. If the cache is at capacity, the least recently used item should be evicted before adding a new one.",
        "entry_point": "LRUCache",
        "docstring": "class LRUCache(int):\n\"\"\"\nA class representing an LRU Cache with a given capacity.\n\nThe constructor takes an integer 'capacity' as an argument.\n\nMethods:\n    get(key: int) -> int or str:\n        Returns the value associated with the given key if present in the cache.\n        Otherwise, it returns None.\n\n    put(key: int, value: int or str, update: bool = False) -> None:\n        Adds or updates the value associated with the given key in the cache.\n        If the cache is at capacity, the least recently used item is evicted before adding a new one.\n\"\"\"",
        "unit_tests": "# Test 1: Test get method with existing key\nassert LRUCache(3).put(1, 1)\nassert LRUCache(3).get(1) == 1\n\n# Test 2: Test get method with non-existing key\nassert LRUCache(3).get(2) is None\n\n# Test 3: Test put method with existing key and update\nassert LRUCache(3).put(1, 2)\nassert LRUCache(3).get(1) == 2\n\n# Test 4: Test put method with new key and update\nassert LRUCache(3).put(4, 4)\nassert LRUCache(3).get(1) == 1\nassert LRUCache(3).get(4) == 4\n\n# Test 5: Test put method with capacity reached and eviction\nassert LRUCache(2).put(1, 1)\nassert LRUCache(2).put(2, 2)\nassert LRUCache(2).get(1) == 1\nassert LRUCache(2).get(2) == 2\nassert LRUCache(2).put(3, 3) is None\nassert LRUCache(2).get(1) is None"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "sumArray",
        "docstring": "def sumArray(arr: list) -> int : \n\"\"\"\nThe sumArray function takes a list of numbers as an argument and returns the sum of all the numbers in the list.\n:param arr: list of numbers\n:type arr: list\n:return: int: The sum of all the numbers in the list.\n\"\"\"",
        "unit_tests": "assert sumArray([]) == 0\nassert sumArray([1]) == 1\nassert sumArray([1, 2, 3]) == 6\nassert sumArray([-1, 0, 1]) == 0\nassert sumArray([2, 2, 2]) == 6"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseArray",
        "docstring": "def reverseArray(arr: List[int], n: int) -> List[int] :\n\"\"\"\nReverse the first 'n' elements of the given list 'arr'.\n\nArguments:\n- arr: List[int] - The input list.\n- n: int - The number of elements to be reversed.\n\nReturns:\n- List[int] - A new list containing the reversed elements of the given list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseArray( [], 0 ) == []\n# Test case 2: List with 1 element\nassert reverseArray( [1], 1 ) == [1]\n# Test case 3: List with 2 elements\nassert reverseArray( [1, 2], 2 ) == [2, 1]\n# Test case 4: List with more than 2 elements\nassert reverseArray( [1, 2, 3], 3 ) == [3, 2, 1]\n# Test case 5: Negative number of elements to reverse\nassert reverseArray( [1, 2, 3], -1 ) == [1, 2, 3]"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "findMax",
        "docstring": "def findMax(list: List[int]) -> int :\n\"\"\"\nFinds the maximum integer in the given list.\n\nParameters:\n    list (List[int]): A list of integers.\n\nReturns:\n    int: The maximum integer in the list.\n\"\"\"",
        "unit_tests": "# Test 1: Given an empty list, the function should return None\nassert findMax([]) is None\n\n# Test 2: Given a list with one integer, the function should return that integer\nassert findMax([1]) == 1\n\n# Test 3: Given a list with multiple integers, the function should return the maximum integer\nassert findMax([3, 1, 4, 1, 5]) == 5\n\n# Test 4: Given a list with negative integers, the function should return the maximum negative integer\nassert findMax([-3, -1, -4, -1, -5]) == -1\n\n# Test 5: Given a list with zero, the function should return zero\nassert findMax([0]) == 0"
    },
    {
        "title": "Factory Method Design Pattern for a Shape Class",
        "description": "Implement the Factory Method Design Pattern for a shape class. The shape class should have a factory method that returns an instance of a specific shape based on a string argument. The available shapes are: Circle, Square, and Triangle. The shape classes should have a method to calculate their area and a property to store their color.",
        "entry_point": "createShape",
        "docstring": "def createShape(shapeType: str) -> Shape :\n\"\"\"\nThis function creates an instance of a specific shape based on the given shapeType string argument.\n\nParameters:\n- shapeType (str): The name of the shape to be created. It can be either \"Circle\", \"Square\", or \"Triangle\".\n\nReturns:\n- A new instance of the requested shape class.\n\"\"\"",
        "unit_tests": "# Test creating a circle shape\nassert isinstance(createShape(\"Circle\"), Circle)\nassert isinstance(createShape(\"Circle\").color, str)\nassert createShape(\"Circle\").area(10) >= 31.41592653589793\n\n# Test creating a square shape\nassert isinstance(createShape(\"Square\"), Square)\nassert isinstance(createShape(\"Square\").color, str)\nassert createShape(\"Square\").area(5) == 25.0\n\n# Test creating a triangle shape\nassert isinstance(createShape(\"Triangle\"), Triangle)\nassert isinstance(createShape(\"Triangle\").color, str)\nassert createShape(\"Triangle\").area(3, 4) >= 6.0\n\n# Test creating an invalid shape\nassert raiseException(createShape, \"Invalid shape type\") when createShape(\"InvalidShape\")"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nMerges two input lists of integers in a sorted order and returns the merged list.\n\nArguments:\n    list1: A list of integers to be merged\n    list2: A list of integers to be merged\n\nReturn:\n    A list of integers representing the merged lists in sorted order.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty lists\nassert mergeList([] , []) == []\n\n# Test case 2: Single element lists\nassert mergeList([1], [2]) == [1, 2]\nassert mergeList([2], [1]) == [1, 2]\n\n# Test case 3: Lists with same elements\nassert mergeList([1, 1], [1, 1]) == [1, 1, 1]\n\n# Test case 4: Lists with same length and different elements\nassert mergeList([1, 2], [3, 4]) == [1, 2, 3, 4]\n\n# Test case 5: Lists with different lengths and common elements\nassert mergeList([1, 2, 3], [2, 3, 4]) == [1, 2, 3, 3, 4]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(list: List[int]) -> List[int] :\n\"\"\"\nThis function takes a list of integers as an argument and returns a new list with the same integers in reverse order.\n\nParameters:\n- list (List[int]): The list of integers to be reversed.\n\nReturns:\n- List[int]: A new list containing the integers from the input list in reverse order.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseList([]) == []\n\n# Test case 2: List with one element\nassert reverseList([1]) == [1]\n\n# Test case 3: List with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: List with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: List with duplicate elements\nassert reverseList([1, 2, 2, 3]) == [3, 2, 2, 1]"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "removeDuplicates",
        "docstring": "def removeDuplicates(list: List[int]) -> List[int] : \n\"\"\"\nRemove all duplicates from the given list of numbers and return the updated list.\n\nParameters:\n- list: A list of integers\n\nReturn Type:\nA list of integers without any duplicates\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert removeDuplicates([]) == []\n\n# Test case 2: List with no duplicates\nassert removeDuplicates([1, 2, 3, 4]) == [1, 2, 3, 4]\n\n# Test case 3: List with duplicates\nassert removeDuplicates([1, 2, 3, 2, 4, 3]) == [1, 2, 3, 4]\n\n# Test case 4: List with duplicate at the beginning\nassert removeDuplicates([2, 1, 2, 3, 4]) == [1, 2, 3, 4]\n\n# Test case 5: List with duplicate at the end\nassert removeDuplicates([1, 2, 3, 4, 3]) == [1, 2, 3, 4]"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nMerges two sorted lists into one sorted list.\n\nParameters:\n    list1: A list of integers representing the first list to be merged.\n    list2: A list of integers representing the second list to be merged.\n\nReturns:\n    A merged list of integers, which is the concatenation of list1 and list2 in sorted order.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty lists\nassert mergeList([] , []) == []\n\n# Test case 2: Merging two lists with same elements\nassert mergeList([1,2], [1,2]) == [1, 2]\n\n# Test case 3: Merging two lists with different elements\nassert mergeList([1,2], [3,4]) == [1, 2, 3, 4]\n\n# Test case 4: Merging two lists with different lengths\nassert mergeList([1,2], [3]) == [1, 2, 3]\n\n# Test case 5: Merging two lists with negative numbers\nassert mergeList([-1, 0], [-2, -3]) == [-2, -3, -1, 0]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "calculateArea",
        "docstring": "def calculateArea(width: float, height: float) -> float :\n\"\"\"Calculate the area of a rectangle given its width and height.\"\"\"",
        "unit_tests": "# Test case 1: Given width and height are positive numbers, then the area should be positive\nassert calculateArea(3.5, 2.1) > 0\n# Test case 2: Given width and height are zero, then the area should be zero\nassert calculateArea(0, 0) == 0\n# Test case 3: Given width is zero and height is not, then the area should be zero\nassert calculateArea(0, 3.5) == 0\n# Test case 4: Given width and height are negative numbers, then the area should be positive\nassert calculateArea(-2.5, -3.1) > 0\n# Test case 5: Given width is a large positive number and height is a small positive number, then the area should be large and positive\nassert calculateArea(10000.5, 1.2) > 0"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "isPrime",
        "docstring": "def isPrime(number: int) -> bool :\n\"\"\"\nChecks whether the given number is a prime number or not. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.\n\nParameters:\n- number: The number to check if it's prime or not. It should be an integer.\n\nReturns:\n- bool: Returns True if the number is prime, False otherwise.\n\"\"\"",
        "unit_tests": "# Test case 1: Positive integer greater than 1\nassert isPrime(2) == True\n# Test case 2: Negative integer\nassert isPrime(-1) == False\n# Test case 3: Zero\nassert isPrime(0) == False\n# Test case 4: Even prime number\nassert isPrime(3) == True\n# Test case 5: Odd composite number\nassert isPrime(5) == True\n# Test case 6: Large composite number\nassert isPrime(31) == True\n# Test case 7: Small prime number\nassert isPrime(11) == True\n# Test case 8: Large prime number\nassert isPrime(101) == True\n# Test case 9: Large composite number\nassert isPrime(103) == True\n# Test case 10: Large composite number with many divisors\nassert isPrime(96) == False\n# Test case 11: Large composite number with many divisors\nassert isPrime(97) == True\n# Test case 12: Edge case: 1\nassert isPrime(1) == True"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: list, list2: list) -> list:\n\"\"\"\nMerges two lists into a single list.\n\nParameters:\n- list1: A list of type list.\n- list2: A list of type list.\n\nReturns:\n- A new list that is the result of merging list1 and list2.\n\"\"\"",
        "unit_tests": "# Test case 1: Both lists are empty\nassert mergeList([][], []) == []\n\n# Test case 2: Both lists are equal\nassert mergeList([1, 2, 3], [1, 2, 3]) == [1, 2, 3]\n\n# Test case 3: One list is empty, the other is not\nassert mergeList([], [1, 2, 3]) == [1, 2, 3]\n\n# Test case 4: Both lists have duplicates\nassert mergeList([1, 2, 2], [2, 3, 2]) == [1, 2, 2, 3]\n\n# Test case 5: Both lists have different elements\nassert mergeList([1, 2], [3, 4]) == [1, 2, 3, 4]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "calculateAverage",
        "docstring": "def calculateAverage(numbers: List[float]) -> float :\n\"\"\"\nCalculate the average of a list of numbers.\n\nParameters:\n    numbers (List[float]): A list of numbers to find the average of.\n\nReturns:\n    The average of the numbers in the list. The return type is float.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert calculateAverage([]) == 0.0\n\n# Test case 2: List with one number\nassert calculateAverage([1.0]) == 1.0\n\n# Test case 3: List with two numbers\nassert calculateAverage([1.0, 2.0]) == 1.5\n\n# Test case 4: List with negative numbers\nassert calculateAverage([-1.0, -2.0]) == -1.5\n\n# Test case 5: List with a large number\nassert calculateAverage([1000000.0]) == 1000000.0"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "isValidEmail",
        "docstring": "def isValidEmail(email: str) -> bool :\n\"\"\"\nThis function checks if the given email address is valid or not.\nIt takes an email address as a string as an argument and returns a boolean value indicating whether the email is valid or not.\n\"\"\"",
        "unit_tests": "# Test case 1: Valid email address\nassert isValidEmail(\"test@example.com\") == True\n# Test case 2: Invalid email address with missing @ symbol\nassert isValidEmail(\"testexample.com\") == False\n# Test case 3: Invalid email address with missing . symbol\nassert isValidEmail(\"test@example\") == False\n# Test case 4: Invalid email address with extra characters\nassert isValidEmail(\"test@example.com@example.com\") == False\n# Test case 5: Invalid email address with empty string\nassert isValidEmail(\"\") == False"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nMerges two sorted lists into a single sorted list.\n\nArguments:\n    list1: A list of integers representing the first list.\n    list2: A list of integers representing the second list.\n\nReturns:\n    A new list that is the merged list of the two input lists.\n\"\"\"",
        "unit_tests": "# Test 1: merge empty lists\nassert mergeList([] , []) == []\n# Test 2: merge lists with no common elements\nassert mergeList([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n# Test 3: merge lists with common elements\nassert mergeList([1, 2, 3], [3, 4, 3]) == [1, 2, 3, 3, 4]\n# Test 4: merge lists with one element each\nassert mergeList([1], [2]) == [1, 2]\n# Test 5: merge lists with same elements\nassert mergeList([1, 1], [1, 1]) == [1, 1, 1]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(list: List[int]) -> List[int] :\n\"\"\"\nReverses the given list of integers and returns the reversed list\n:param list: A list of integers\n:type list: List[int]\n:return: A list of integers in reverse order\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseList([]) == []\n\n# Test case 2: List with single element\nassert reverseList([1]) == [1]\n\n# Test case 3: List with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: List with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: List with duplicate elements\nassert reverseList([1, 1, 2, 2]) == [2, 2, 1, 1]"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "sumArray",
        "docstring": "def sumArray(arr: List[int]) -> int : \n\"\"\"\nSum the integers in the given list.\n\nParameters:\n    arr (List[int]): A list of integers.\n\nReturns:\n    int: The sum of all integers in the given list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert sumArray([]) == 0\n\n# Test case 2: List with single integer\nassert sumArray([1]) == 1\n\n# Test case 3: List with multiple integers\nassert sumArray([1, 2, 3, 4]) == 10\n\n# Test case 4: List with negative integers\nassert sumArray([-1, -2, -3]) == -6\n\n# Test case 5: List with floating point numbers\nassert sumArray([1.0, 2.5, 3.75]) == 7.25"
    },
    {
        "title": "N-Queens Problem",
        "description": "Write a function named 'solveNQueens' that takes an integer 'n' as an argument and returns a list of valid positions for 'n' queens on an 'n'x'n' chessboard such that no two queens attack each other. You can assume that n is valid and that the board is initially empty.",
        "entry_point": "solveNQueens",
        "docstring": "def solveNQueens(n: int) -> List[List[int]]:\n\"\"\"\nThis function solves the N-Queens problem by recursively placing queens on the given chessboard.\n\nThe N-Queens problem is a classic problem in computer science and mathematics. Given an NxN chessboard and N queens, the problem is to place these N queens on the board such that no two queens attack each other.\n\nThis function takes an integer 'n' as an argument and returns a list of valid positions for 'n' queens on an 'n'x'n' chessboard.\n\nParameters:\n- n (int): The size of the chessboard and the number of queens to be placed.\n\nReturn:\n- A list of valid positions for 'n' queens on an 'n'x'n' chessboard. Each inner list represents the row and column position of a queen.\n\"\"\"",
        "unit_tests": "# Test 1: Check if the function returns an empty list for n = 0\nassert solveNQueens(0) == []\n\n# Test 2: Check if the function returns a valid solution for n = 1\nassert len(solveNQueens(1)) == 1\nassert len(solveNQueens(1)[0]) == 2\n\n# Test 3: Check if the function returns a valid solution for n = 2\nassert len(solveNQueens(2)) == 2\nassert len(solveNQueens(2)[0]) == 2 and len(solveNQueens(2)[1]) == 2\n\n# Test 4: Check if the function returns a valid solution for n = 3\nassert len(solveNQueens(3)) >= 1\nassert all([len(positions) == 2 for positions in solveNQueens(3)])\n\n# Test 5: Check if the function returns an empty list for invalid input\nassert solveNQueens(-1) == []"
    },
    {
        "title": "Knight's Tour Problem",
        "description": "Write a function named 'solveKnightsTour' that takes a 2D chessboard of size 'n'x'n' as an argument and returns True if a knight can make a tour of the board (visit every square exactly once), and False otherwise. You can assume that n is odd.",
        "entry_point": "solveKnightsTour",
        "docstring": "def solveKnightsTour(board: List[List[int]]) -> bool : \n\"\"\"\nWrite a function named 'solveKnightsTour' that takes a 2D chessboard of size n x n as an argument and returns True if a knight can make a tour of the board (visit every square exactly once), and False otherwise. You can assume that n is odd.\n\nParameters:\n- board (List[List[int]]): A 2D chessboard of size n x n. The initial position of the knight is at the center of the board (n//2, n//2).\n\nReturn Type:\n- bool: Returns True if a knight can make a tour of the board, and False otherwise.\n\"\"\"",
        "unit_tests": "# Test 1: Check if the function returns True for a valid board\nassert solveKnightsTour([[0]*len(board[0]) for _ in range(len(board))]) == True\n# Test 2: Check if the function returns False for a board with no solution\nassert solveKnightsTour([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == False\n# Test 3: Check if the function returns False for a board with an odd-sized square\nassert solveKnightsTour([[1, 1], [1, 1]]) == False\n# Test 4: Check if the function returns True for a board with a solution\nassert solveKnightsTour([[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]]) == True\n# Test 5: Check if the function returns False for a board with a dead end\nassert solveKnightsTour([[0, 1, 1, 1, 0], [0, 1, 0, 1, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [1, 1, 1, 1, 1]]) == False"
    },
    {
        "title": "Subset Sum Problem",
        "description": "Write a function named 'canSum' that takes a list of integers 'candidates' and an integer 'target' as arguments and returns True if there exists a subset of candidates that sums up to target, and False otherwise.",
        "entry_point": "canSum",
        "docstring": "def canSum(candidates: List[int], target: int) -> bool :\n\"\"\"\nWrite a docstring for the canSum function.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list and target 0\nassert canSum([], 0) == True\n# Test case 2: Empty list and non-zero target\nassert canSum([], 3) == False\n# Test case 3: List with positive integers and target equal to their sum\nassert canSum([1, 2, 3], 6) == True\n# Test case 4: List with negative integers and target equal to their sum\nassert canSum([-1, -2, -3], -6) == True\n# Test case 5: List with duplicate integers and target equal to their sum\nassert canSum([1, 1, 1, 1], 4) == True\n# Test case 6: List with positive integers and non-target value\nassert canSum([1, 2, 3], 5) == False\n# Test case 7: List with negative integers and non-target value\nassert canSum([-1, -2, -3], 5) == False\n# Test case 8: List with large integers and target equal to their sum\nassert canSum([1000000001, 1000000001], 2000000002) == True\n# Test case 9: List with large integers and non-target value\nassert canSum([1000000001, 1000000001], 2000000003) == False\n# Test case 10: Edge case: empty list and negative target\nassert canSum([], -1) == False"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Write a function named fib that takes an integer n and returns the nth Fibonacci number. Use recursion.",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int: \n\"\"\"\nThis function generates the nth Fibonacci number using recursion.\n\nParameters:\n    n (int): The position of the number in the Fibonacci sequence to be returned.\n\nReturns:\n    int: The nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fib(0) == 0\n\n# Test case 2: n = 1\nassert fib(1) == 1\n\n# Test case 3: n = 2\nassert fib(2) == 1\n\n# Test case 4: n = 3\nassert fib(3) == 2\n\n# Test case 5: n = 10\nassert fib(10) == 55\n\n# Test case 6: n = negative number\nassert fib(-1) is None\nassert fib(-2) is None"
    },
    {
        "title": "Binary search",
        "description": "Write a function named binarySearch that takes a sorted list and a value to search for. The function should return the index of the value in the list if it exists, otherwise it should return -1.",
        "entry_point": "binarySearch",
        "docstring": "def binarySearch(list: List[int], value: int) -> int : \n\"\"\"\nThis function implements a binary search algorithm on a sorted list.\n\nParameters:\n- list (List[int]): A sorted list of numbers to be searched.\n- value (int): The number to search for in the list.\n\nReturns:\n- int: The index of the value in the list if it exists, otherwise -1.\n\"\"\"",
        "unit_tests": "# Test case 1: The value is present in the list\nassert binarySearch([1, 3, 5, 7, 9], 5) == 3\n# Test case 2: The value is at the beginning of the list\nassert binarySearch([1, 3, 5, 7, 9], 1) == 0\n# Test case 3: The value is at the end of the list\nassert binarySearch([1, 3, 5, 7, 9], 9) == 4\n# Test case 4: The value is not present in the list\nassert binarySearch([1, 3, 5, 7, 9], 0) == -1\n# Test case 5: The list is empty\nassert binarySearch([], 1) == -1"
    },
    {
        "title": "Quick sort",
        "description": "Write a function named quickSort that takes a list as an argument and sorts it using the QuickSort algorithm.",
        "entry_point": "quickSort",
        "docstring": "def quickSort(list: List[Any]) -> List[Any] : \n\"\"\"\nSorts the given list using the QuickSort algorithm.\n\nParameters:\n    list: List[Any]\n        The list to be sorted.\n\nReturns:\n    List[Any]\n        The sorted list.\n\"\"\"",
        "unit_tests": "# Test case 1: empty list\nassert quickSort([]) == []\n\n# Test case 2: list with single element\nassert quickSort([3]) == [3]\n\n# Test case 3: list with few elements\nassert quickSort([1, 3, 5, 2]) == [1, 2, 3, 5]\n\n# Test case 4: list with negative numbers\nassert quickSort([-1, -3, -5, -2]) == [-5, -3, -1, -2]\n\n# Test case 5: list with duplicate elements\nassert quickSort([1, 3, 5, 1, 5]) == [1, 1, 3, 5, 5]"
    },
    {
        "title": "Find Maximum Value in a Binary Tree",
        "description": "Write a recursive function to find the maximum value in a binary tree.",
        "entry_point": "maxValue",
        "docstring": "def maxValue(node: BinaryTreeNode) -> int :\n            \"\"\"\n            Recursive function to find the maximum value in a binary tree.\n\n            Parameters:\n                node (BinaryTreeNode): The root node of the binary tree.\n\n            Returns:\n                int: The maximum value in the binary tree.\n            \"\"\"",
        "unit_tests": "# Test case 1: Empty tree\nassert maxValue(None) == None\n\n# Test case 2: Tree with one node\nnode1 = BinaryTreeNode(5)\nassert maxValue(node1) == 5\n\n# Test case 3: Tree with multiple nodes and one maximum value\nnode2 = BinaryTreeNode(3)\nnode2.left = BinaryTreeNode(2)\nnode2.right = BinaryTreeNode(5)\nassert maxValue(node2) == 5\n\n# Test case 4: Tree with multiple nodes and a non-unique maximum value\nnode3 = BinaryTreeNode(5)\nnode3.left = BinaryTreeNode(3)\nnode3.right = BinaryTreeNode(5)\nassert maxValue(node3) == 5\n\n# Test case 5: Tree with left and right subtrees\nnode4 = BinaryTreeNode(5)\nnode4.left = BinaryTreeNode(3)\nnode4.right = BinaryTreeNode(7)\nassert maxValue(node4) == 7\n\n# Test case 6: Tree with negative numbers\nnode5 = BinaryTreeNode(-2)\nnode5.left = BinaryTreeNode(-3)\nnode5.right = BinaryTreeNode(-1)\nassert maxValue(node5) == -2"
    },
    {
        "title": "Reverse a Linked List",
        "description": "Write a recursive function to reverse a singly linked list.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(head: Node) -> Node : \n\"\"\"\nReverse a singly linked list recursively.\n\nParameters:\n    head (Node): The head of the linked list to be reversed.\n\nReturns:\n    Node: The new head of the reversed linked list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseList(None) == None\n\n# Test case 2: Single element list\nnode1 = Node(1)\nassert reverseList(node1) == node1\n\n# Test case 3: Reverse a simple linked list\nnode2 = Node(1)\nnode2.next = Node(2)\nnode2.next.next = Node(3)\nexpected_output = Node(3)\nexpected_output.next = Node(2)\nexpected_output.next.next = Node(1)\nassert reverseList(node2) == expected_output\n\n# Test case 4: Reverse a linked list with cycles\nnode3 = Node(1)\nnode3.next = Node(2)\nnode3.next.next = node3\nexpected_output = Node(2)\nexpected_output.next = Node(1)\nexpected_output.next.next = node3\nassert reverseList(node3) == expected_output\n\n# Test case 5: Reverse a linked list with multiple nodes\nnode4 = Node(1)\nnode4.next = Node(2)\nnode4.next.next = Node(3)\nnode4.next.next.next = Node(4)\nexpected_output = Node(4)\nexpected_output.next = Node(3)\nexpected_output.next.next = Node(2)\nexpected_output.next.next.next = Node(1)\nassert reverseList(node4) == expected_output"
    },
    {
        "title": "Find Element in a Binary Search Tree",
        "description": "Write a recursive function to search for an element in a binary search tree.",
        "entry_point": "searchInBST",
        "docstring": "def searchInBST(root: Node, key: int) -> Node: \"\"\"\n# This function performs a recursive search for a given key in a binary search tree.\n#\n# Parameters:\n#     root (Node): The root node of the binary search tree.\n#     key (int): The integer to search for.\n#\n# Returns:\n#     If the key is found, the function returns the Node containing the key.\n#     If the key is not found, the function returns None.\n# \"\"\"",
        "unit_tests": "# Test case 1: Search for an element present in the tree\nassert searchInBST(Node(5), 5) == Node(5)\n\n# Test case 2: Search for an element smaller than the root\nassert searchInBST(Node(5), 3) is None\n\n# Test case 3: Search for an element greater than the root\nassert searchInBST(Node(5), 7) is None\n\n# Test case 4: Search for an element in an empty tree\nassert searchInBST(None, 5) is None\n\n# Test case 5: Search for an element in a tree with multiple nodes\nassert searchInBST(Node(5, Node(3), Node(7)), 3) == Node(3)"
    },
    {
        "title": "Find the max number in a list",
        "description": "Write a function named 'find_max' that takes a list as an argument and returns the maximum number in the list.",
        "entry_point": "find_max",
        "docstring": "def find_max(numbers: List[int]) -> int : \n\"\"\"\nThis function takes a list of integers as an argument and returns the maximum number in the list.\n\"\"\"",
        "unit_tests": "assert find_max([]) == ValueError\nassert find_max([1]) == 1\nassert find_max([1, 2, 3]) == 3\nassert find_max([-1, 0, -2]) == -1\nassert find_max([1, 2, 1]) == 2"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Write a function called \"fibonacci\" that takes an integer n and returns the nth Fibonacci number. The function should have the following signature: int fibonacci(int n).",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nThis function generates the nth Fibonacci number using recursion.\nThe input to this function is an integer 'n' representing the position of the Fibonacci number to be generated.\nThe function returns an integer representing the nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: Base case - n = 0\nassert fibonacci(0) == 0\n\n# Test case 2: Base case - n = 1\nassert fibonacci(1) == 1\n\n# Test case 3: Testing a number in the sequence\nassert fibonacci(5) == 5\n\n# Test case 4: Testing a number beyond the sequence\nassert fibonacci(10) == 55\n\n# Test case 5: Testing negative number\nassert fibonacci(-1) == \"Error: Negative number not allowed\""
    },
    {
        "title": "Reverse linked list",
        "description": "Write a function called \"reverseList\" that takes a linked list as an argument and returns the reversed linked list. The function should have the following signature: ListNode reverseList(ListNode head).",
        "entry_point": "reverseList",
        "docstring": "def reverseList(head: ListNode) -> ListNode:\n\"\"\"\nReverses a singly linked list.\n\nArguments:\nhead (ListNode): A linked list.\n\nReturns:\nListNode: The reversed linked list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseList(None) is None\n\n# Test case 2: Single element list\nnode1 = ListNode(1)\nassert reverseList(node1) == node1\n\n# Test case 3: List with two elements\nnode1 = ListNode(1)\nnode2 = ListNode(2)\nnode1.next = node2\nassert reverseList(node1) == node2\nassert reverseList(node2) == node1\n\n# Test case 4: List with three elements\nnode1 = ListNode(1)\nnode2 = ListNode(2)\nnode3 = ListNode(3)\nnode1.next = node2\nnode2.next = node3\nassert reverseList(node1) == node3\nassert reverseList(node3) == node2\nassert reverseList(node2) == node1\n\n# Test case 5: List with multiple elements\nnode1 = ListNode(1)\nnode2 = ListNode(2)\nnode3 = ListNode(3)\nnode4 = ListNode(4)\nnode5 = ListNode(5)\nnode1.next = node2\nnode2.next = node3\nnode3.next = node4\nnode4.next = node5\nassert reverseList(node1) == node5\nassert reverseList(node5) == node4\nassert reverseList(node4) == node3\nassert reverseList(node3) == node2\nassert reverseList(node2) == node1"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Implement a recursive function to calculate the nth number of the Fibonacci sequence.",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int :\n\"\"\"\nCalculate the nth number of the Fibonacci sequence using recursion.\n\nParameters:\n    n (int): the position of the number in the sequence to be calculated.\n\nReturn Type:\n    int: the nth number of the Fibonacci sequence.\n\"\"\"",
        "unit_tests": "# Test 1: base case\nassert fib(0) == 0\n# Test 2: first number in the sequence\nassert fib(1) == 1\n# Test 3: second number in the sequence\nassert fib(2) == 1\n# Test 4: third number in the sequence\nassert fib(3) == 2\n# Test 5: larger number in the sequence\nassert fib(10) == 55"
    },
    {
        "title": "Reverse Linked List",
        "description": "Implement a recursive function to reverse a linked list.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(head: LinkedListNode) -> LinkedListNode: \n\"\"\"\nImplement a recursive function to reverse a linked list.\n\nParameters:\n- head: A LinkedListNode with a value and a next pointer.\n\nReturns:\n- A LinkedListNode representing the head of the reversed linked list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverseList(None) is None\n\n# Test case 2: List with one node\nassert reverseList(LinkedListNode(1, None)) == LinkedListNode(1, None)\n\n# Test case 3: List with multiple nodes\nassert reverseList(LinkedListNode(1, LinkedListNode(2, LinkedListNode(3, None)))) \\\n            == LinkedListNode(3, LinkedListNode(2, LinkedListNode(1, None)))\n\n# Test case 4: List with a cycle\nassert reverseList(LinkedListNode(1, LinkedListNode(2, LinkedListNode(3, LinkedListNode(4, LinkedListNode(5, LinkedListNode(1, None))))))) \\\n            == LinkedListNode(5, LinkedListNode(4, LinkedListNode(3, LinkedListNode(2, LinkedListNode(1, LinkedListNode(1, None)))))))\n\n# Test case 5: List with negative numbers\nassert reverseList(LinkedListNode(-1, LinkedListNode(-2, LinkedListNode(-3, None)))) \\\n            == LinkedListNode(-3, LinkedListListNode(-2, LinkedListNode(-1, None)))"
    },
    {
        "title": "Binary Search Tree",
        "description": "Implement a recursive function to insert a new node in a binary search tree.",
        "entry_point": "insertNode",
        "docstring": "def insertNode(node: BinaryTreeNode, newData: int) -> BinaryTreeNode :\n\"\"\"\nInserts a new node with the given data in the binary search tree rooted at the given node.\n\nParameters:\n    node: The root node of the binary search tree. It is of type BinaryTreeNode.\n    newData: The data to be inserted in the binary search tree. It is of type int.\n\nReturns:\n    The root node of the binary search tree after inserting the new data. It is of type BinaryTreeNode.\n\"\"\"",
        "unit_tests": "# Test case 1: Insert a new node with a smaller value than the root node\nassert insertNode(BinaryTreeNode(5), 3) == BinaryTreeNode(3, BinaryTreeNode(5))\n# Test case 2: Insert a new node with a larger value than the root node\nassert insertNode(BinaryTreeNode(5), 7) == BinaryTreeNode(5, BinaryTreeNode(7))\n# Test case 3: Insert a new node with the same value as the root node\nassert insertNode(BinaryTreeNode(5), 5) == BinaryTreeNode(5, None)\n# Test case 4: Insert a new node with a smaller value than the left child of the root node\nassert insertNode(BinaryTreeNode(5, BinaryTreeNode(3)), 2) == BinaryTreeNode(5, BinaryTreeNode(2, BinaryTreeNode(3)))\n# Test case 5: Insert a new node with a larger value than the right child of the root node\nassert insertNode(BinaryTreeNode(5, BinaryTreeNode(7)), 8) == BinaryTreeNode(5, BinaryTreeNode(7, BinaryTreeNode(8)))"
    },
    {
        "title": "Factorial using recursion",
        "description": "Implement the function factorial(n: int) : int. The function should compute the factorial of the given integer n using recursion.",
        "entry_point": "factorial",
        "docstring": "def factorial(n: int) -> int : \n            \"\"\"\n            Compute the factorial of the given integer n using recursion.\n\n            Parameters:\n                n (int): The non-negative integer for which the factorial is to be computed.\n\n            Returns:\n                The factorial of the given integer n.\n            \"\"\"",
        "unit_tests": "assert factorial(0) == 1\nassert factorial(1) == 1\nassert factorial(5) == 120\nassert factorial(10) == 3628800\nassert factorial(-1) is None\nassert factorial(100) is None"
    },
    {
        "title": "Fibonacci sequence using recursion",
        "description": "Implement the function fibonacci(n: int) : int. The function should compute the nth Fibonacci number using recursion.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nCompute the nth Fibonacci number using recursion\n\nParameters:\n  n: int, the position of the Fibonacci number to be computed.\n\nReturns:\n  int, the nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: base case\nassert fibonacci(0) == 0\n# Test case 2: first Fibonacci number\nassert fibonacci(1) == 1\n# Test case 3: second Fibonacci number\nassert fibonacci(2) == 1\n# Test case 4: Fibonacci number at position 5\nassert fibonacci(5) == 3\n# Test case 5: Fibonacci number at position 10\nassert fibonacci(10) == 55"
    },
    {
        "title": "Sort a list using merge sort",
        "description": "Write a function called \"mergeSort\" that takes a list as an argument and returns a new sorted list. Use merge sort algorithm.",
        "entry_point": "mergeSort",
        "docstring": "def mergeSort(input_list: List[Any]) -> List[Any] :\n\"\"\"\nThis function takes a list as an argument and returns a new sorted list using merge sort algorithm.\n\nParameters:\n    input_list (List[Any]): The list to be sorted.\n\nReturns:\n    List[Any]: A new sorted list.\n\"\"\"",
        "unit_tests": "# Test case 1: empty list\nassert mergeSort([]) == []\n# Test case 2: list with one element\nassert mergeSort([3]) == [3]\n# Test case 3: list with two elements in ascending order\nassert mergeSort([1, 2]) == [1, 2]\n# Test case 4: list with two elements in descending order\nassert mergeSort([5, 4]) == [4, 5]\n# Test case 5: list with multiple elements in random order\nassert mergeSort([4, 2, 5, 1]) == [1, 2, 4, 5]\n# Test case 6: list with duplicate elements\nassert mergeSort([3, 3, 3]) == [3, 3, 3]\n# Test case 7: list with negative numbers\nassert mergeSort([-2, -1, 0]) == [-2, -1, 0]\n# Test case 8: list with large numbers\nassert mergeSort([1000000, 999999, 999998]) == [999998, 999999, 1000000]\n# Test case 9: list with empty and non-empty sub-lists\nassert mergeSort([[], 1, 2, [], 0]) == [0, 1, 2]\n# Test case 10: list with nested lists\nassert mergeSort([[1, 2], [3, 4], [5, 6]]) == [[1, 2], [3, 4], [5, 6]]"
    },
    {
        "title": "Sort a list using quick sort",
        "description": "Write a function called \"quickSort\" that takes a list as an argument and returns a new sorted list. Use quick sort algorithm.",
        "entry_point": "quickSort",
        "docstring": "def quickSort(inputList: List[Any]) -> List[Any] :\n\"\"\"\nSort a given input list using quick sort algorithm.\n\nParameters:\n    inputList (List[Any]): The list to be sorted.\n\nReturns:\n    List[Any]: A new sorted list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert quickSort([]) == []\n\n# Test case 2: List with one element\nassert quickSort([3]) == [3]\n\n# Test case 3: List with two elements in ascending order\nassert quickSort([1, 2]) == [1, 2]\n\n# Test case 4: List with two elements in descending order\nassert quickSort([2, 1]) == [1, 2]\n\n# Test case 5: List with multiple elements in random order\nassert quickSort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5]\n# Test case 6: List with negative numbers\nassert quickSort([-1, -3, -5, -2]) == [-5, -3, -2, -1]\n# Test case 7: List with duplicates\nassert quickSort([3, 3, 1, 2, 3]) == [1, 2, 3, 3, 3]\n# Test case 8: List with all same elements\nassert quickSort([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3]\n# Test case 9: List with empty string and strings\nassert quickSort([\"\", \"apple\", \"banana\", \"cherry\"]) == [\"\", \"apple\", \"banana\", \"cherry\"]\n# Test case 10: List with list as elements\nassert quickSort([[1, 2], [3, 4], [5, 6]]) == [[1, 2], [3, 4], [5, 6]]"
    },
    {
        "title": "Sort a list using insertion sort",
        "description": "Write a function called \"insertionSort\" that takes a list as an argument and returns a new sorted list. Use insertion sort algorithm.",
        "entry_point": "insertionSort",
        "docstring": "def insertionSort(list_to_sort: list) -> list:\n\"\"\"\nThis function implements the insertion sort algorithm to sort a given list of numbers in ascending order.\n\nParameters:\n    list_to_sort (list): A list of numbers to be sorted.\n\nReturn Type:\n    list: A new sorted list.\n\"\"\"",
        "unit_tests": "assert insertionSort([]) == []\nassert insertionSort([1]) == [1]\nassert insertionSort([1, 2]) == [1, 2]\nassert insertionSort([2, 1]) == [1, 2]\nassert insertionSort([3, 2, 1]) == [1, 2, 3]\nassert insertionSort([1, 2, 3]) == [1, 2, 3]\nassert insertionSort([3, 1, 2]) == [1, 2, 3]\nassert insertionSort([1, 3, 2]) == [1, 2, 3]\nassert insertionSort([2, 2]) == [2, 2]\nassert insertionSort([1, 2, 2]) == [1, 2, 2]"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Write a recursive function `fib` that computes the nth Fibonacci number using memoization. \n\nArguments:\n- n: an integer, the position of the number in the sequence\n\nReturns:\n- An integer, the nth Fibonacci number",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int: \n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "assert fib(0) == 0\nassert fib(1) == 1\nassert fib(2) == 1\nassert fib(3) == 2\nassert fib(4) == 3\nassert fib(5) == 5\nassert fib(10) == 55\nassert fib(-1) is None\nassert fib(20) == 6765"
    },
    {
        "title": "Longest Common Subsequence",
        "description": "Given two strings `s1` and `s2`, write a recursive function `lcs` that finds the longest common subsequence between them. \n\nArguments:\n- s1: a string, the first string\n- s2: a string, the second string\n\nReturns:\n- A list of characters, the longest common subsequence",
        "entry_point": "lcs",
        "docstring": "def lcs(s1: str, s2: str) -> List[str]:\n\"\"\"\nFinds the longest common subsequence between two strings s1 and s2.\n\nArguments:\n- s1: a string, the first string\n- s2: a string, the second string\n\nReturns:\n- A list of characters, the longest common subsequence\n\"\"\"",
        "unit_tests": "# Test 1: Empty strings return empty list\nassert lcs(\"\", \"\") == []\n# Test 2: Identical strings return identical list\nassert lcs(\"abc\", \"abc\") == [\"a\", \"b\", \"c\"]\n# Test 3: One character in each string\nassert lcs(\"ab\", \"ac\") == [\"a\"]\n# Test 4: Empty string vs non-empty string\nassert lcs(\"\", \"abc\") == []\n# Test 5: Non-empty strings with no common characters\nassert lcs(\"abcd\", \"efgh\") == []"
    },
    {
        "title": "Edit Distance",
        "description": "Given two strings `s1` and `s2`, write a recursive function `edit_distance` that computes the minimum number of edits (insertions, deletions, or substitutions) required to make one string identical to another. \n\nArguments:\n- s1: a string, the first string\n- s2: a string, the second string\n\nReturns:\n- An integer, the minimum number of edits required",
        "entry_point": "edit_distance",
        "docstring": "def edit_distance(s1: str, s2: str) -> int:\n\"\"\"\nThis function computes the minimum number of edits (insertions, deletions, or substitutions) required to make one string identical to another.\n\nArguments:\n- s1: a string, the first string\n- s2: a string, the second string\n\nReturns:\n- An integer, the minimum number of edits required\n\"\"\"",
        "unit_tests": "# Test 1: Empty strings are identical\nassert edit_distance('', '') == 0\n# Test 2: Edit distance between two identical strings\nassert edit_distance('abc', 'abc') == 0\n# Test 3: Edit distance between two strings with one character difference\nassert edit_distance('abcd', 'acbd') == 1\n# Test 4: Edit distance between two strings with different lengths\nassert edit_distance('abcd', 'efgh') >= 3\n# Test 5: Edge case: empty string compared to non-empty string\nassert edit_distance('', 'abc') >= 1"
    },
    {
        "title": "Reverse a List",
        "description": "Write a recursive function named \"reverseList\" that takes a list as an argument and returns a new list which is the reverse of the input list. For example, given the input list [1, 2, 3], the function should return [3, 2, 1].",
        "entry_point": "reverseList",
        "docstring": "def reverseList(inputList: List[Any]) -> List[Any] :\n\"\"\"\nThis function takes a list as an argument and returns a new list which is the reverse of the input list.\n\nParameters:\n- inputList (List[Any]): The input list to be reversed.\n\nReturn Type:\n- List[Any]: A new list which is the reverse of the input list.\n\"\"\"",
        "unit_tests": "# Test case 1: empty list\nassert reverseList([]) == []\n\n# Test case 2: list with one element\nassert reverseList([1]) == [1]\n\n# Test case 3: list with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: list with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: list with strings\nassert reverseList([\"a\", \"b\", \"c\"]) == [\"c\", \"b\", \"a\"]"
    },
    {
        "title": "Factorial of a Number",
        "description": "Write a recursive function named \"factorial\" that takes an integer as an argument and returns the factorial of that number. For example, given the input 5, the function should return 120.",
        "entry_point": "factorial",
        "docstring": "def factorial(number: int) -> int :\n\"\"\"\nThis function calculates the factorial of a given integer number using recursion.\n\nParameters:\n- number (int): The non-negative integer for which the factorial is to be calculated.\n\nReturns:\n- int: The factorial of the given integer number.\n\"\"\"",
        "unit_tests": "# Test case 1: Factorial of 0\nassert factorial(0) == 1\n\n# Test case 2: Factorial of 1\nassert factorial(1) == 1\n\n# Test case 3: Factorial of a positive number\nassert factorial(5) == 120\n\n# Test case 4: Factorial of a negative number (should raise an error)\ndef test_factorial_negative():\n    with assertRaises(ValueError):\n        factorial(-5)\n\n# Test case 5: Factorial of a large number (should not cause a stack overflow)\nassert factorial(100) == 933262154439065960528606700588235294117n"
    },
    {
        "title": "Sum of elements in an array",
        "description": "Write a function `sumArray` that takes an array `arr` of numbers as an argument and returns the sum of all the numbers in the array.",
        "entry_point": "sumArray",
        "docstring": "def sumArray(arr: List[int]) -> int: \n\"\"\"\nThis function computes the sum of all the numbers in the given list.\n\nParameters:\n- arr: A list of integers.\n\nReturns:\n- The sum of all the integers in the list.\n\"\"\"",
        "unit_tests": "# Test 1: Empty array\nassert sumArray([]) == 0\n\n# Test 2: Array with single element\nassert sumArray([1]) == 1\n\n# Test 3: Array with multiple elements\nassert sumArray([1, 2, 3, 4]) == 10\n\n# Test 4: Array with negative numbers\nassert sumArray([-1, 0, 1]) == 0\n\n# Test 5: Array with large numbers\nassert sumArray([1000000001, 1000000002, 1000000003]) == 3000000006"
    },
    {
        "title": "Reverse an array",
        "description": "Write a function `reverseArray` that takes an array `arr` as an argument and returns a new array with the elements of the original array in reverse order.",
        "entry_point": "reverseArray",
        "docstring": "def reverseArray(arr: list) -> list : \n\"\"\"\nThis function takes a list as an argument and returns a new list with the elements in reverse order.\n\n:param arr: A list of any type of elements\n:type arr: list\n:return: A new list with the elements in reverse order\n:rtype: list\n\"\"\"",
        "unit_tests": "assert reverseArray([1, 2, 3]) == [3, 2, 1]\nassert reverseArray([]) == []\nassert reverseArray([4, 5]) == [5, 4]\nassert reverseArray([1, 2, 3, 4]) == [4, 3, 2, 1]\nassert reverseArray([0]) == [0]"
    },
    {
        "title": "Find the longest subarray with distinct elements",
        "description": "Write a function `findLongestSubArray` that takes an array `arr` as an argument and returns the length of the longest contiguous subarray of `arr` with only distinct elements.",
        "entry_point": "findLongestSubArray",
        "docstring": "def findLongestSubArray(arr: List[int]) -> int : \n\"\"\"\nFinds the length of the longest contiguous subarray of the input list with only distinct elements.\n\nParameters:\n    arr (List[int]): A list of integers.\n\nReturns:\n    int: The length of the longest contiguous subarray of the input list with only distinct elements.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert findLongestSubArray([]) == 0\n\n# Test case 2: List with distinct elements\nassert findLongestSubArray([1, 2, 3, 4]) == 4\n\n# Test case 3: List with duplicate elements\nassert findLongestSubArray([1, 2, 2, 3, 3, 3]) == 3\n\n# Test case 4: List with all duplicates\nassert findLongestSubArray([1, 1, 1, 1]) == 1\n\n# Test case 5: List with single element\nassert findLongestSubArray([1]) == 1"
    },
    {
        "title": "Reverse List",
        "description": "Write a function called 'reverse_list' that takes a single argument: a list. The function should reverse the order of the elements in the list and return the reversed list.",
        "entry_point": "reverse_list",
        "docstring": "def reverse_list(input_list: List[Any]) -> List[Any] :\n\"\"\"\nThis function takes a single argument, a list, and returns the reversed list.\n\nParameters:\n    input_list (List[Any]): The list to be reversed.\n\nReturns:\n    List[Any]: The reversed list.\n\"\"\"",
        "unit_tests": "# Test case 1: Test with an empty list\nassert reverse_list([]) == []\n\n# Test case 2: Test with a list containing single element\nassert reverse_list([1]) == [1]\n\n# Test case 3: Test with a list containing multiple elements\nassert reverse_list([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: Test with a list containing negative numbers\nassert reverse_list([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: Test with a list containing strings\nassert reverse_list([\"a\", \"b\", \"c\"]) == [\"c\", \"b\", \"a\"]"
    },
    {
        "title": "Find Middle Element",
        "description": "Write a function called 'find_middle_element' that takes a single argument: a list. The function should find and return the middle element of the list. If the list has an odd number of elements, the middle element should be the one at the middle index. If the list has an even number of elements, the middle element should be the average of the two middle elements.",
        "entry_point": "find_middle_element",
        "docstring": "def find_middle_element(list: list) -> any: \"\"\"\nFinds the middle element of the given list.\n\nIf the list has an odd number of elements, the middle element is the one at the middle index.\nIf the list has an even number of elements, the middle element is the average of the two middle elements.\n\nParameters:\n    list (list): A list of any type.\n\nReturn Type:\n    Any: A single element of the list type.\n\"\"\"",
        "unit_tests": "# Test 1: List with odd number of elements\nassert find_middle_element([1, 2, 3, 4, 5]) == 3\n# Test 2: List with even number of elements\nassert find_middle_element([1, 2, 3, 4, 5, 6]) == (3, 4)\n# Test 3: Empty list\nassert find_middle_element([]) is None\n# Test 4: List with single element\nassert find_middle_element([1]) == 1\n# Test 5: List with two elements\nassert find_middle_element([1, 2]) == 1"
    },
    {
        "title": "Remove Duplicates",
        "description": "Write a function called 'remove_duplicates' that takes a single argument: a list. The function should return a new list that contains only the unique elements of the original list. The order of the elements in the returned list does not matter.",
        "entry_point": "remove_duplicates",
        "docstring": "def remove_duplicates(input_list: List[Any]) -> List[Any] :\n\"\"\"\nThis function takes a single argument: a list. The function returns a new list that contains only the unique elements of the original list. The order of the elements in the returned list does not matter.\n\nParameters:\n- input_list: A list of Any type\n\nReturns:\n- A new list of Any type that contains only the unique elements of the input_list\n\"\"\"",
        "unit_tests": "assert remove_duplicates([]) == []\nassert remove_duplicates([1]) == [1]\nassert remove_duplicates([1, 1]) == [1]\nassert remove_duplicates([1, 2, 2, 3]) == [1, 2, 3]\nassert remove_duplicates([1, 2, 3, 3]) == [1, 2, 3]\nassert remove_duplicates([\"apple\", \"banana\", \"banana\"]) == [\"apple\", \"banana\"]\nassert remove_duplicates([1, 1.0, 1]) == [1.0]\nassert remove_duplicates([None, None, None]) == [None]\nassert remove_duplicates([1, 2, 3, 1]) == [1, 2, 3]"
    },
    {
        "title": "Find the sum of two numbers",
        "description": "Write a function named \"add\" that takes two numbers as arguments and returns their sum.",
        "entry_point": "add",
        "docstring": "def add(num1: int, num2: int) -> int :\n\"\"\"\nThis function takes two integer numbers as arguments and returns the sum of the two numbers.\n\nParameters:\n- num1: An integer number\n- num2: An integer number\n\nReturns:\nAn integer number representing the sum of the two input numbers.\n\"\"\"",
        "unit_tests": "# Test 1: Test the function with positive integers\nassert add(2, 3) == 5\n# Test 2: Test the function with zero and a positive integer\nassert add(0, 5) == 5\n# Test 3: Test the function with negative integers\nassert add(-2, -3) == -5\n# Test 4: Test the function with zero and zero\nassert add(0, 0) == 0\n# Test 5: Test the function with a large positive integer and a small positive integer\nassert add(1000000, 5) == 1000005"
    },
    {
        "title": "Reverse a string",
        "description": "Write a function named \"reverseString\" that takes a string as an argument and returns the reversed string.",
        "entry_point": "reverseString",
        "docstring": "def reverseString(inputString: str) -> str :\n\"\"\"\nThis function takes a string as an argument and returns the reversed string.\n\nParameters:\n    inputString (str): The string to be reversed.\n\nReturns:\n    str: The reversed string.\n\"\"\"",
        "unit_tests": "# Test 1: Empty string\nassert reverseString(\"\") == \"\"\n\n# Test 2: Single character string\nassert reverseString(\"a\") == \"a\"\n\n# Test 3: String with multiple characters\nassert reverseString(\"hello\") == \"olleh\"\n\n# Test 4: String with spaces\nassert reverseString(\"hello world\") == \"dlrow olleh\"\n\n# Test 5: String with special characters\nassert reverseString(\"!@#$%^&*()_+-=[]{}|;:,.<>?\") == \";:>.<,;|/=(+_)-*^%&*($#%@!\""
    },
    {
        "title": "Find the first non-repeating character",
        "description": "Write a function named \"firstNonRepeatingCharacter\" that takes a string as an argument and returns the first character that appears only once in the string.",
        "entry_point": "firstNonRepeatingCharacter",
        "docstring": "def firstNonRepeatingCharacter(str: str) -> str:\n\"\"\"\nThis function takes a string as an argument and returns the first character that appears only once in the string.\n\nParameters:\n- str (str): The input string.\n\nReturn:\n- str: The first non-repeating character in the string.\n\"\"\"",
        "unit_tests": "# Test 1: Empty string\nassert firstNonRepeatingCharacter(\"\") == \"\"\n# Test 2: Single character string\nassert firstNonRepeatingCharacter(\"a\") == \"a\"\n# Test 3: String with repeating characters\nassert firstNonRepeatingCharacter(\"abccba\") == \"a\"\n# Test 4: String with only repeating characters\nassert firstNonRepeatingCharacter(\"aaabbccc\") == \"\"\n# Test 5: String with multiple non-repeating characters\nassert firstNonRepeatingCharacter(\"abcd\") == \"a\""
    },
    {
        "title": "Breadth First Search",
        "description": "Implement a breadth-first search algorithm to find the shortest path between two nodes in an undirected graph.",
        "entry_point": "bfs",
        "docstring": "def bfs(graph: dict, start: str, end: str) -> List[str] :\n            \"\"\"Implement a breadth-first search algorithm to find the shortest path between two nodes in an undirected graph.\"\"\"\n            # TODO: Implement BFS algorithm here\n            pass",
        "unit_tests": "# Test case 1: BFS should find the shortest path between two connected nodes\nassert bfs({\"A\": [\"B\"], \"B\": [\"A\"]}, \"A\", \"B\") == [\"A\", \"B\"]\n# Test case 2: BFS should find the shortest path between two nodes with multiple paths\nassert bfs({\"A\": [\"B\", \"C\"], \"B\": [\"A\", \"C\"], \"C\": [\"B\"]}, \"A\", \"C\") == [\"A\", \"B\", \"C\"]\n# Test case 3: BFS should return an empty list if the start and end nodes are not connected\nassert bfs({\"A\": [\"B\"], \"B\": [\"C\"]}, \"A\", \"C\") == []\n# Test case 4: BFS should handle graphs with self-loops\nassert bfs({\"A\": [\"A\"]}, \"A\", \"A\") == [\"A\"]\n# Test case 5: BFS should handle graphs with cycles\nassert bfs({\"A\": [\"B\"], \"B\": [\"A\"]}, \"A\", \"B\") == [\"A\", \"B\"]"
    },
    {
        "title": "Topological Sort",
        "description": "Implement a topological sort algorithm to find the order of finishing all tasks in a directed acyclic graph (DAG).",
        "entry_point": "topological_sort",
        "docstring": "def topological_sort(graph: dict) -> list:\n\"\"\"\nPerforms a topological sort on a given directed acyclic graph (DAG) represented as a dictionary where keys are tasks\nand values are lists of tasks that the current task depends on.\n\nParameters:\n    graph (dict): A dictionary of tasks as keys and their dependencies as lists of keys.\n\nReturn:\n    A list of tasks that can be finished in the order they appear in the graph.\n\"\"\"",
        "unit_tests": "# Test empty graph\nassert topological_sort({}) == []\n# Test graph with no cycles\nassert topological_sort({\"A\": [], \"B\": [\"A\"]}) == [\"A\", \"B\"]\n# Test graph with cycles\nassert topological_sort({\"A\": [\"B\"], \"B\": [\"A\"]}) is None\n# Test graph with multiple entries and exits\nassert topological_sort({\"A\": [\"B\"], \"B\": [\"C\"], \"C\": []}) == [\"C\", \"B\", \"A\"]\n# Test graph with multiple dependencies\nassert topological_sort({\"A\": [\"B\", \"C\"], \"B\": [\"D\"], \"C\": [\"D\"], \"D\": []}) == [\"D\", \"C\", \"B\", \"A\"]"
    },
    {
        "title": "Depth of a Binary Tree",
        "description": "Write a function `treeDepth` that takes a binary tree represented as a dictionary and returns the depth of the tree.",
        "entry_point": "treeDepth",
        "docstring": "def treeDepth(tree: dict) -> int : \n\"\"\"\nDescribe the treeDepth function here.\n\"\"\"",
        "unit_tests": "assert treeDepth({\"value\": 1, \"left\": {\"value\": 2, \"left\": None, \"right\": None}, \"right\": {\"value\": 3, \"left\": None, \"right\": None}}) == 2\nassert treeDepth({\"value\": 1}) == 0\nassert treeDepth({\"value\": 1, \"left\": {\"value\": 2, \"left\": {\"value\": 3, \"left\": None, \"right\": None}, \"right\": {\"value\": 4, \"left\": None, \"right\": None}}, \"right\": {\"value\": 3, \"left\": None, \"right\": None}}) == 3\nassert treeDepth({\"value\": 1, \"left\": {\"value\": 2, \"left\": {\"value\": 3, \"left\": None, \"right\": {\"value\": 4, \"left\": None, \"right\": None}}, \"right\": None}, \"right\": {\"value\": 3, \"left\": None, \"right\": None}}) == 3\nassert treeDepth({\"value\": 1, \"left\": {\"value\": 2, \"left\": {\"value\": 3, \"left\": None, \"right\": {\"value\": 4, \"left\": None, \"right\": None}}, \"right\": {\"value\": 5, \"left\": None, \"right\": None}}, \"right\": {\"value\": 3, \"left\": {\"value\": 4, \"left\": None, \"right\": None}, \"right\": {\"value\": 6, \"left\": None, \"right\": None}}}) == 4"
    },
    {
        "title": "Maximum Value in a Binary Tree",
        "description": "Write a function `treeMax` that takes a binary tree represented as a dictionary and returns the maximum value in the tree.",
        "entry_point": "treeMax",
        "docstring": "def treeMax(tree: dict) -> int:\n\"\"\"\nThis function takes a binary tree represented as a dictionary and returns the maximum value in the tree.\n\nThe dictionary keys represent node labels and the values are other dictionaries, each containing 'left' and 'right' keys that point to child nodes and a 'value' attribute that holds the value of the node.\n\nThe function recursively traverses the tree to find the maximum value.\n\"\"\"",
        "unit_tests": "# Test 1: Empty tree\nassert treeMax({}) == 0\n# Test 2: Tree with one node\nassert treeMax({'value': 1}) == 1\n# Test 3: Tree with two nodes\nassert treeMax({'value': 1, 'left': {'value': 2}, 'right': {'value': 3}}) == 3\n# Test 4: Tree with multiple nodes\nassert treeMax({'value': 1, 'left': {'value': 2, 'left': {'value': 4}, 'right': {'value': 5}}, 'right': {'value': 3, 'left': {'value': 6}, 'right': {'value': 7}}}) == 7\n# Test 5: Tree with negative values\nassert treeMax({'value': -1, 'left': {'value': -2, 'left': {'value': -3}, 'right': {'value': -4}}, 'right': {'value': -5, 'left': {'value': -6}, 'right': {'value': -7}}}) == -1"
    },
    {
        "title": "Find the longest common prefix",
        "description": "Write a function that finds the longest common prefix string amongst an array of strings.",
        "entry_point": "longestCommonPrefix",
        "docstring": "def longestCommonPrefix(strs: List[str]) -> str: \"\"\"\nFind the longest common prefix among a list of given strings.\n\nParameters:\n    strs (List[str]): A list of strings.\n\nReturns:\n    str: The longest common prefix among all the strings in the list.\n    If no common prefix exists, an empty string is returned.\n\"\"\"",
        "unit_tests": "assert longestCommonPrefix([\"flower\", \"flow\", \"flight\"]) == \"fl\"\nassert longestCommonPrefix([\"dog\", \"racecar\", \"car\"]) == \"\"\nassert longestCommonPrefix([\"ab\", \"abc\", \"abcd\"]) == \"ab\"\nassert longestCommonPrefix([\"ab\", \"abc\", \"abcd\", \"abcde\"]) == \"ab\"\nassert longestCommonPrefix([\"\", \"abc\", \"abcd\"]) == \"\""
    },
    {
        "title": "Autocomplete Function",
        "description": "Write a function that finds words in a given list of words which starts with the given prefix. The list of words is given as an array and the prefix is given as a string.",
        "entry_point": "autocomplete",
        "docstring": "def autocomplete(words: List[str], prefix: str) -> List[str] :\n\"\"\"\nFinds words in a given list of words which starts with the given prefix.\n\nParameters:\n    words: List of strings representing the list of words.\n    prefix: String representing the prefix of the words to be found.\n\nReturns:\n    List of strings representing the words that starts with the given prefix.\n\"\"\"",
        "unit_tests": "# Test 1: Empty list of words and empty prefix\nassert autocomplete([], \"\") == []\n\n# Test 2: Empty list of words and non-empty prefix\nassert autocomplete([], \"prefix\") == []\n\n# Test 3: Non-empty list of words and empty prefix\nassert autocomplete([\"apple\", \"banana\", \"cherry\"], \"\") == []\n\n# Test 4: Non-empty list of words and prefix that is present in the list\nassert autocomplete([\"apple\", \"banana\", \"cherry\"], \"app\") == [\"apple\"]\n\n# Test 5: Non-empty list of words and prefix that is not present in the list\nassert autocomplete([\"apple\", \"banana\", \"cherry\"], \"cher\") == []"
    },
    {
        "title": "Reverse a List",
        "description": "Write a function named \"reverseList\" that takes a list as an argument and returns a new list which is the reverse of the input list.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(inputList: List[Any]) -> List[Any] :\n            \"\"\"\n            This function takes a list as an argument and returns a new list which is the reverse of the input list.\n\n            Parameters:\n                inputList (List[Any]): A list to be reversed.\n\n            Return:\n                A new list which is the reverse of the input list.\n            \"\"\"",
        "unit_tests": "# Test case 1: Test empty list\nassert reverseList([]) == []\n\n# Test case 2: Test list with single element\nassert reverseList([1]) == [1]\n\n# Test case 3: Test list with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: Test list with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: Test list with floats\nassert reverseList([1.1, 2.2, 3.3]) == [3.3, 2.2, 1.1]"
    },
    {
        "title": "Find the middle element of a list",
        "description": "Write a function named \"findMiddleElement\" that takes a list as an argument and returns the middle element of the list. If the list has an odd number of elements, return the middle element. If the list has an even number of elements, return the pair of middle elements.",
        "entry_point": "findMiddleElement",
        "docstring": "def findMiddleElement(list: list) -> Union[Any, tuple[Any, Any]]:\n\"\"\"\nFinds the middle element or pair of middle elements of a given list.\n\nParameters:\n    list (list): A list of any type\n\nReturns:\n    If the list has an odd number of elements, returns the middle element.\n    If the list has an even number of elements, returns a tuple of the middle elements.\n\"\"\"",
        "unit_tests": "# Test case 1: List with an odd number of elements\nassert findMiddleElement([1, 2, 3, 4, 5]) == 3\n# Test case 2: List with an even number of elements\nassert findMiddleElement([1, 2, 3, 4, 5, 6]) == (3, 4)\n# Test case 3: Empty list\nassert findMiddleElement([]) is None\n# Test case 4: List with only one element\nassert findMiddleElement([1]) == 1\n# Test case 5: List with an even number of elements and non-numeric types\nassert findMiddleElement([\"apple\", \"banana\", \"cherry\", \"date\"]) == (\"cherry\", \"date\")"
    },
    {
        "title": "Max Heap",
        "description": "Implement a max heap using an array and write a function to extract the maximum value from it.",
        "entry_point": "extractMax",
        "docstring": "def extractMax(arr: List[int]) -> int : \n\"\"\"\nThis function extracts the maximum value from a given list using max heap property.\n\nParameters:\n- arr: A list of integers representing a max heap\n\nReturn Type:\n- An integer representing the maximum value in the list\n\"\"\"",
        "unit_tests": "# Test case 1: Max heap with single element\nassert extractMax([1]) == 1\n\n# Test case 2: Max heap with multiple elements\nassert extractMax([4, 2, 9, 6, 5]) == 9\n\n# Test case 3: Max heap with empty list\nassert extractMax([]) == None\n\n# Test case 4: Max heap with negative numbers\nassert extractMax([-2, -5, -1, 0]) == -2\n\n# Test case 5: Max heap with duplicate maximum values\nassert extractMax([5, 5, 5, 5]) == 5"
    },
    {
        "title": "Min Heap",
        "description": "Implement a min heap using an array and write a function to extract the minimum value from it.",
        "entry_point": "extractMin",
        "docstring": "def extractMin(heap: List[int]) -> int :\n\"\"\"\nExtracts the minimum value from a min heap.\n\nParameters:\n- heap (List[int]): A list representing the min heap\n\nReturns:\n- int: The minimum value in the min heap.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty heap\nassert extractMin([]) == None\n\n# Test case 2: Single element heap\nheap = [5]\nassert extractMin(heap) == 5\nheap = []\n\n# Test case 3: Heap with multiple elements\nheap = [3, 5, 1, 7, 2]\nassert extractMin(heap) == 1\nassert extractMin(heap) == 3\nassert extractMin(heap) == 2\nassert extractMin(heap) == 5\n\n# Test case 4: Heap with maximum value at the end\nheap = [3, 5, 1, 7, 2, 8]\nassert extractMin(heap) == 1\nassert extractMin(heap) == 3\nassert extractMin(heap) == 2\nassert extractMin(heap) == 5\nassert extractMin(heap) == 7\n\n# Test case 5: Heap with minimum value at the end\nheap = [1, 5, 3, 7, 2, 8]\nassert extractMin(heap) == 1\nassert extractMin(heap) == 1\nassert extractMin(heap) == 2\nassert extractMin(heap) == 3\nassert extractMin(heap) == 5"
    },
    {
        "title": "Heap Sort",
        "description": "Implement heap sort using a max heap and write a function to perform the sorting.",
        "entry_point": "heapSort",
        "docstring": "def heapSort(array: List[int]) :\n\"\"\"\nSorts the given array in place using heap sort algorithm.\nThe heap sort algorithm is a comparison-based sorting algorithm based on a binary heap data structure.\nThe array is first transformed into a max heap, which is a complete binary tree where the key of each node is greater than or equal to the keys of its children.\nThe last node is then swapped with the root, and the heap property is restored. This process is repeated until the entire array is sorted.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert heapSort([]) == []\n\n# Test case 2: List with one element\nassert heapSort([1]) == [1]\n\n# Test case 3: List with few elements\nassert heapSort([4, 2, 6, 1, 3]) == [6, 4, 3, 2, 1]\n\n# Test case 4: List with many elements\nassert heapSort([10, 8, 6, 3, 5, 2, 9, 7, 1, 4]) == [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n\n# Test case 5: List with negative numbers\nassert heapSort([-5, -2, 0, 3, 6]) == [6, 3, 0, -2, -5]"
    },
    {
        "title": "Reverse a Linked List",
        "description": "Write a function named \"reverseList\" that takes as an argument a linked list and returns a new linked list with the same elements but in reverse order.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(head: ListNode) -> ListNode: \n\"\"\"\nThis function takes a single argument, head, which is a ListNode object representing the head of a singly linked list.\nThe function returns a new ListNode object representing the head of the reversed singly linked list.\n\"\"\"",
        "unit_tests": "assert reverseList(reverseList(createList(input1))) == createList(expectedOutput1)\nassert reverseList(reverseList(createList(input2))) == createList(expectedOutput2)\nassert reverseList(reverseList(createList(input3))) == createList(expectedOutput3)\nassert reverseList(createList([1, 2])) == createList([2, 1])\nassert reverseList(createList([1])) == createList([1])\nassert reverseList(createList([1, 2, 3])) == createList([3, 2, 1])"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: list, list2: list) -> list :\n\"\"\"\nMerges two lists into a single list.\n\nParameters:\nlist1 (list): The first list to be merged.\nlist2 (list): The second list to be merged.\n\nReturns:\nlist: A new list that is the merged result of the given two lists.\n\"\"\"",
        "unit_tests": "# Test 1: Merging empty lists\nassert mergeList([] , []) == []\n# Test 2: Merging lists with same elements\nassert mergeList([1, 2], [1, 2]) == [1, 2, 1, 2]\n# Test 3: Merging lists with different elements\nassert mergeList([1, 2], [3, 4]) == [1, 2, 3, 4]\n# Test 4: Merging lists with different sizes\nassert mergeList([1], [2, 3]) == [1, 2, 3]\n# Test 5: Merging lists with negative elements\nassert mergeList([-1], [1, 2]) == [-1, 1, 2]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(inputList: List[int]) -> List[int] :\n\"\"\"\nThis function takes a list of integers as an argument and returns a new list with the integers in reverse order.\n\nArguments:\n    inputList (List[int]): A list of integers to be reversed.\n\nReturns:\n    List[int]: A new list with the integers in reverse order.\n\"\"\"",
        "unit_tests": "# Test 1: Given an empty list, the function should return an empty list\nassert reverseList([]) == []\n\n# Test 2: Given a list with one integer, the function should return a new list with the same integer\nassert reverseList([1]) == [1]\n\n# Test 3: Given a list with multiple integers, the function should return a new list with the integers in reverse order\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test 4: Given a list with negative integers, the function should return a new list with the integers in reverse order\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test 5: Given a list with floating point numbers, the function should return a new list with the numbers in reverse order\nassert reverseList([1.5, 2.5, 3.5]) == [3.5, 2.5, 1.5]"
    },
    {
        "title": "Sum List",
        "description": "Write a function called 'sumList' that accepts a list of numbers as an argument and returns the sum of all the numbers in the list.",
        "entry_point": "sumList",
        "docstring": "def sumList(numbers: List[int]) -> int :\n\"\"\"\nAccepts a list of numbers and returns the sum of all the numbers in the list.\n\nParameters:\n    numbers (List[int]): A list of numbers to be summed.\n\nReturn Type:\n    int: The sum of all the numbers in the list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert sumList([]) == 0\n\n# Test case 2: List with single element\nassert sumList([1]) == 1\n\n# Test case 3: List with multiple elements\nassert sumList([1, 2, 3]) == 6\n\n# Test case 4: List with negative numbers\nassert sumList([-1, 2, 3]) == 0\n\n# Test case 5: List with duplicate numbers\nassert sumList([1, 1, 1]) == 3"
    },
    {
        "title": "Reverse List",
        "description": "Write a function called 'reverseList' that accepts a list as an argument and returns a new list with the same elements but in reverse order.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(list: List[Any]) -> List[Any] :\n\"\"\"\nAccepts a list as an argument and returns a new list with the same elements but in reverse order.\n\nParameters:\n    list (List[Any]): A list of any type to be reversed.\n\nReturns:\n    List[Any]: A new list with the same elements as the input list but in reverse order.\n\"\"\"",
        "unit_tests": "# Test case 1: Test empty list\nassert reverseList([]) == []\n\n# Test case 2: Test list with single element\nassert reverseList([1]) == [1]\n\n# Test case 3: Test list with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: Test list with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test case 5: Test list with floats\nassert reverseList([1.1, 2.2, 3.3]) == [3.3, 2.2, 1.1]"
    },
    {
        "title": "Multiply List",
        "description": "Write a function called 'multiplyList' that accepts a list of numbers as an argument and returns the product of all the numbers in the list.",
        "entry_point": "multiplyList",
        "docstring": "def multiplyList(list: List[int]) -> int : \n            \"\"\"Accepts a list of integers and returns the product of all the numbers in the list.\"\"\"",
        "unit_tests": "# Test case 1: Given an empty list, return 1 as the product\nassert multiplyList([]) == 1\n\n# Test case 2: Given a list with one number, return that number as the product\nassert multiplyList([3]) == 3\n\n# Test case 3: Given a list with multiple numbers, return the product of all the numbers\nassert multiplyList([1, 2, 3]) == 6\n\n# Test case 4: Given a list with negative numbers, return the product of all the numbers\nassert multiplyList([-1, -2, -3]) == 6\n\n# Test case 5: Given a list with zero, return 0 as the product\nassert multiplyList([0]) == 0"
    },
    {
        "title": "Factorial Function",
        "description": "Write a recursive function called 'factorial' that takes a positive integer 'n' as an argument and returns the product of all positive integers from 1 to n.",
        "entry_point": "factorial",
        "docstring": "def factorial(n: int) -> int :\n\"\"\"\nA recursive function that computes the factorial of a given positive integer.\n\nParameters:\n    n: An integer representing the number for which the factorial is to be computed.\n\nReturns:\n    An integer representing the factorial of the given number.\n\"\"\"",
        "unit_tests": "# Test case 1: Positive integer as input\nassert factorial(5) == 120\n\n# Test case 2: Zero as input\nassert factorial(0) == 1\n\n# Test case 3: Negative integer as input\nassert factorial(-5) == AssertionError(\"Factorial is not defined for negative integers\")\n\n# Test case 4: Large positive integer as input\nassert factorial(100) == 93326215443944152681699238856266700490715968264381621468592915384928611574496985\n\n# Test case 5: Non-integer input\nassert factorial(3.5) == AssertionError(\"Factorial is only defined for integers\")"
    },
    {
        "title": "Reverse List",
        "description": "Write a recursive function called 'reverseList' that takes a list 'lst' as an argument and returns a new list that contains the elements of the original list in reverse order.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(lst: List[Any]) -> List[Any] :\n\"\"\"\nA recursive function that takes a list as an argument and returns a new list that contains the elements of the original list in reverse order.\n\nParameters:\n- lst (List[Any]): The input list.\n\nReturn Type:\nList[Any]: A new list that contains the elements of the original list in reverse order.\n\"\"\"",
        "unit_tests": "# Test case 1: Test empty list\nassert reverseList([]) == []\n# Test case 2: Test list with one element\nassert reverseList([1]) == [1]\n# Test case 3: Test list with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n# Test case 4: Test list with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n# Test case 5: Test list with floating point numbers\nassert reverseList([1.5, 2.5, 3.5]) == [3.5, 2.5, 1.5]"
    },
    {
        "title": "Fibonacci Sequence",
        "description": "Write a recursive function called 'fibonacci' that takes a positive integer 'n' as an argument and returns the nth number in the Fibonacci sequence.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nThis function returns the nth number in the Fibonacci sequence.\n\nThe Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, starting from 0 and 1.\n\nThis function uses recursion to calculate the nth number in the Fibonacci sequence.\n\nParameter:\n    n (int): The position of the number to be returned in the Fibonacci sequence.\n\nReturn:\n    int: The nth number in the Fibonacci sequence.\n\"\"\"",
        "unit_tests": "assert fibonacci(0) == 0\nassert fibonacci(1) == 1\nassert fibonacci(2) == 1\nassert fibonacci(3) == 2\nassert fibonacci(4) == 3\nassert fibonacci(5) == 5\nassert fibonacci(10) == 55\nassert fibonacci(20) == 6765\nassert fibonacci(50) == 12586269025"
    },
    {
        "title": "Curry Addition",
        "description": "Write a function `add` that takes two numbers as arguments and returns their sum. Now write a curried version `addCurry` of this function that accepts one argument and returns a function that accepts the second argument.",
        "entry_point": "addCurry",
        "docstring": "def add(num1: float, num2: float) -> float :\n\"\"\"\nThis function accepts two float numbers as arguments and returns their sum.\n\nParameters:\n- num1 (float): The first number to be added\n- num2 (float): The second number to be added\n\nReturns:\nThe sum of num1 and num2 as a float\n\"\"\"",
        "unit_tests": "assert add(2, 3) == 5\nassert add(1, 1) == 2\nassert add(-1, 1) == 0\n\nassert addCurry(2)(3) == 5\nassert addCurry(1)(1) == 2\nassert addCurry(-1)(1) == 0\n\nassert addCurry(2)(-3) == -1\nassert addCurry(2)(0) == 2\nassert addCurry(0)(2) == 2"
    },
    {
        "title": "Curry Maximum",
        "description": "Write a function `max` that takes two numbers as arguments and returns the greater one. Now write a curried version `maxCurry` of this function that accepts one argument and returns a function that accepts the second argument.",
        "entry_point": "maxCurry",
        "docstring": "def max(num1: float, num2: float) -> Union[float, int]:\n\"\"\"\nTakes two numbers as arguments and returns the greater one.\n\n:param num1: The first number (float or int)\n:type num1: Union[int, float]\n:param num2: The second number (float or int)\n:type num2: Union[int, float]\n:return: The greater number (float or int)\n\"\"\"",
        "unit_tests": "assert max(5, 3) == 5\nassert max(3, 5) == 5\nassert max(5, 5) == 5\n\nassert maxCurry(5)(3) == 5\nassert maxCurry(3)(5) == 5\nassert maxCurry(5)(5) == 5\n\nassert maxCurry(5)(6) == 6\nassert maxCurry(6)(5) == 6\nassert maxCurry(5)(5) == 5"
    },
    {
        "title": "Sum of Array Elements",
        "description": "Write a function called 'sum' that takes an array of numbers as an argument and returns the sum of all the numbers in the array.",
        "entry_point": "sum",
        "docstring": "def sum(arr: list[int]) -> int :\n\"\"\"\nThis function takes a list of integers as an argument and returns the sum of all the integers in the list.\n:param arr: list, a list of integers\n:return: int, the sum of all the integers in the list\n\"\"\"",
        "unit_tests": "# Test 1: Test with empty list\nassert sum([]) == 0\n\n# Test 2: Test with a list of positive numbers\nassert sum([1, 2, 3]) == 6\n\n# Test 3: Test with a list of negative numbers\nassert sum([-1, -2, -3]) == -6\n\n# Test 4: Test with a list of zero\nassert sum([0]) == 0\n\n# Test 5: Test with a list of mixed numbers\nassert sum([1, -2, 3, -4]) == 0"
    },
    {
        "title": "Sum of the first n numbers",
        "description": "Write a function named \"sum\" that takes an integer \"n\" as argument and returns the sum of the first n numbers.",
        "entry_point": "sum",
        "docstring": "def sum(n: int) -> int : \n\"\"\"\nSum the first n numbers\n\nParameters:\nn (int): The number of terms to include in the sum.\n\nReturns:\nint: The sum of the first n numbers.\n\"\"\"",
        "unit_tests": "# Test case 1: Sum of first 0 numbers\nassert sum(0) == 0\n\n# Test case 2: Sum of first 1 number\nassert sum(1) == 1\n\n# Test case 3: Sum of first 5 numbers\nassert sum(5) == 15\n\n# Test case 4: Sum of first negative number\nassert sum(-3) == 0\n\n# Test case 5: Sum of first large number\nassert sum(100) == 5050"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Write a function named \"fibonacci\" that takes an integer \"n\" as argument and returns the nth number in the Fibonacci sequence.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nThis function calculates the nth number in the Fibonacci sequence.\n\nParameters:\n- n: An integer representing the position of the number in the Fibonacci sequence.\n\nReturns:\n- The nth number in the Fibonacci sequence.\n\"\"\"",
        "unit_tests": "# Test 1: The function should return 0 for n = 0\nassert fibonacci(0) == 0\n\n# Test 2: The function should return 1 for n = 1\nassert fibonacci(1) == 1\n\n# Test 3: The function should return the correct Fibonacci number for larger inputs\nassert fibonacci(5) == 3\nassert fibonacci(10) == 34\nassert fibonacci(20) == 102334155\n\n# Test 4: The function should handle negative inputs correctly\nassert fibonacci(-1) is None\nassert fibonacci(-2) is None\n\n# Test 5: The function should handle large inputs correctly\nassert fibonacci(1000) == 43466557687940013127661"
    },
    {
        "title": "Longest common subsequence",
        "description": "Write a function named \"lcs\" that takes two strings \"s1\" and \"s2\" as arguments and returns the longest common subsequence between them.",
        "entry_point": "lcs",
        "docstring": "def lcs(s1: str, s2: str) -> str :\n\"\"\"\nThis function takes two strings 's1' and 's2' as input arguments and returns the longest common subsequence between them.\n\"\"\"",
        "unit_tests": "# Test 1: Both strings are empty\nassert lcs(\"\", \"\") == \"\"\n# Test 2: Both strings are equal\nassert lcs(\"hello\", \"hello\") == \"hello\"\n# Test 3: Both strings have one character\nassert lcs(\"a\", \"b\") == \"\"\n# Test 4: One string is empty and the other is not\nassert lcs(\"\", \"hello\") == \"\"\n# Test 5: Longest common subsequence of two different strings\nassert lcs(\"abcde\", \"acd\") == \"acd\""
    },
    {
        "title": "Add Two Numbers",
        "description": "Write a pure function `add` that accepts two arguments, both of type `number`, and returns the sum of these two numbers.",
        "entry_point": "add",
        "docstring": "def add(num1: number, num2: number) -> number : \n\"\"\"\nThis function accepts two arguments, both of type number, and returns the sum of these two numbers.\n\"\"\"",
        "unit_tests": "# Test case 1: Add two positive numbers\nassert add(2, 3) == 5\n\n# Test case 2: Add zero to a number\nassert add(2, 0) == 2\n\n# Test case 3: Add two negative numbers\nassert add(-2, -3) == -5\n\n# Test case 4: Add a large number to a smaller number\nassert add(1000000, 5) == 1000005\n\n# Test case 5: Add two numbers with decimal points\nassert add(3.14, 2.71) == 5.85"
    },
    {
        "title": "Reverse a List",
        "description": "Write a pure function `reverse` that accepts a list of any type as an argument and returns a new list with the elements in reverse order.",
        "entry_point": "reverse",
        "docstring": "def reverse(list: List[Any]) -> List[Any] :\n\"\"\"\nThis function accepts a list of any type as an argument and returns a new list with the elements in reverse order.\n\nParameters:\n- list: A list of any type (List[Any]).\n\nReturn Type:\n- A list of the same type as the input list (List[Any]).\n\"\"\"",
        "unit_tests": "# Test case 1: Reverse an empty list\nassert reverse([]) == []\n\n# Test case 2: Reverse a list with one element\nassert reverse([1]) == [1]\n\n# Test case 3: Reverse a list with multiple elements\nassert reverse([1, 2, 3]) == [3, 2, 1]\n\n# Test case 4: Reverse a list with negative numbers\nassert reverse([1, -2, 3, -4]) == [-4, -3, 3, 1]\n\n# Test case 5: Reverse a list with strings\nassert reverse([\"hello\"]) == [\"hello\"]\nassert reverse([\"hello\", \"world\"]) == [\"world\", \"hello\"]"
    },
    {
        "title": "Filter Even Numbers",
        "description": "Write a pure function `filterEven` that accepts a list of numbers as an argument and returns a new list containing all the even numbers in the original list.",
        "entry_point": "filterEven",
        "docstring": "def filterEven(numbers: List[int]) -> List[int] :\n\"\"\"\nAccepts a list of numbers and returns a new list containing all the even numbers in the original list.\n\nParameters:\n    numbers (List[int]): A list of numbers.\n\nReturns:\n    List[int]: A list of even numbers.\n\"\"\"",
        "unit_tests": "# Test case 1: Filter even numbers from an empty list\nassert filterEven([]) == []\n\n# Test case 2: Filter even numbers from a list with odd numbers\nassert filterEven([1, 2, 3, 4, 5]) == [2, 4]\n\n# Test case 3: Filter even numbers from a list with even numbers\nassert filterEven([2, 4, 6, 8]) == [2, 4, 6, 8]\n\n# Test case 4: Filter even numbers from a list with negative numbers\nassert filterEven([-2, -4, -6]) == [-2, -4]\n\n# Test case 5: Filter even numbers from a list with zero\nassert filterEven([0]) == [0]"
    },
    {
        "title": "Sum two lists",
        "description": "Write a function named \"sumLists\" that takes two lists of numbers and returns a new list containing the sum of corresponding elements. If the lists are of different sizes, the shorter one should be padded with zeros until they are of the same size.",
        "entry_point": "sumLists",
        "docstring": "def sumLists(list1: list, list2: list) -> list:\n            \"\"\"DOCSTRING\"\"\"",
        "unit_tests": "assert sumLists([1, 2], [3, 4]) == [4, 6]\nassert sumLists([1, 2, 3], [3, 4, 5]) == [4, 6, 7]\nassert sumLists([1], [3]) == [1, 3]\nassert sumLists([], [3]) == [3]\nassert sumLists([1, 2], []) == [1, 2]"
    },
    {
        "title": "Sum of Two Numbers in an Array",
        "description": "Write a function that takes an array and returns the sum of the first two numbers in the array.",
        "entry_point": "sumFirstTwoNumbers",
        "docstring": "def sumFirstTwoNumbers(numbers: list[int]) -> int:\n            \"\"\"\n            This function takes a list of integers as an argument and returns the sum of the first two numbers in the list.\n            \"\"\"",
        "unit_tests": "# Test case 1: Input list with 2 elements\nassert sumFirstTwoNumbers([1, 2]) == 3\n\n# Test case 2: Input list with 1 element\nassert sumFirstTwoNumbers([3]) == 3\n\n# Test case 3: Input list with 3 elements\nassert sumFirstTwoNumbers([1, 2, 3]) == 3\n\n# Test case 4: Input list with 4 elements\nassert sumFirstTwoNumbers([1, 2, 3, 4]) == 3\n\n# Test case 5: Input list with 0 elements\nassert sumFirstTwoNumbers([]) == 0"
    },
    {
        "title": "Filter Odd Numbers from an Array",
        "description": "Write a function that takes an array and returns a new array containing only the odd numbers.",
        "entry_point": "filterOddNumbers",
        "docstring": "def filterOddNumbers(numbers: List[Number]) -> List[Number] :\n\"\"\"\nFilter odd numbers from the given array\n\nParameters:\n    numbers: An array of numbers.\n    Type: List[Number]\n\nReturns:\n    A new array containing only the odd numbers from the input array.\n    Type: List[Number]\n\"\"\"",
        "unit_tests": "# Test case 1: Filter odd numbers from an empty list\nassert filterOddNumbers([]) == []\n# Test case 2: Filter odd numbers from an array with even numbers\nassert filterOddNumbers([1, 2, 3, 4, 5]) == [1, 3, 5]\n# Test case 3: Filter odd numbers from an array with only odd numbers\nassert filterOddNumbers([1, 3, 5, 7, 9]) == [1, 3, 5, 7, 9]\n# Test case 4: Filter odd numbers from an array with negative numbers\nassert filterOddNumbers([-1, 0, 1, 2, 3]) == [-1, 1]\n# Test case 5: Filter odd numbers from an array with zero\nassert filterOddNumbers([0, 1, 2, 3, 4]) == [1]"
    },
    {
        "title": "Find the Maximum Number in an Array",
        "description": "Write a function that takes an array and returns the maximum number in the array.",
        "entry_point": "findMaximumNumber",
        "docstring": "def findMaximumNumber(array : list) -> int:\n\"\"\"\nThis function takes an array as a parameter and returns the maximum number in the array.\n\nParameters:\n    - array: A list of numbers.\n\nReturns:\n    - The maximum number in the array.\n\"\"\"",
        "unit_tests": "# Test case 1: Array with positive numbers\nassert findMaximumNumber([1, 2, 3, 4, 5]) == 5\n# Test case 2: Array with negative numbers\nassert findMaximumNumber([-1, -2, -3, -4, -5]) == -1\n# Test case 3: Array with zero\nassert findMaximumNumber([0, 1, 2, 3, 4]) == 5\n# Test case 4: Array with only one number\nassert findMaximumNumber([5]) == 5\n# Test case 5: Empty array\nassert findMaximumNumber([]) == None"
    },
    {
        "title": "Filter even numbers",
        "description": "Write a function `filterEvenNumbers` that takes a list of numbers as an argument and returns a new list that contains only even numbers.",
        "entry_point": "filterEvenNumbers",
        "docstring": "def filterEvenNumbers(numbers: List[int]) -> List[int] :\n            \"\"\"\n            This function filters even numbers from the given list of numbers and returns a new list containing only even numbers.\n\n            :param numbers: A list of numbers.\n            :type numbers: List[int]\n            :return: A new list that contains only even numbers from the given list.\n            :rtype: List[int]\n            \"\"\"",
        "unit_tests": "# Test case 1: Filter even numbers from an empty list\nassert filterEvenNumbers([]) == []\n\n# Test case 2: Filter even numbers from a list containing even numbers\nassert filterEvenNumbers([1, 2, 3, 4, 5, 6]) == [2, 4, 6]\n\n# Test case 3: Filter even numbers from a list containing odd numbers\nassert filterEvenNumbers([1, 3, 5, 7]) == []\n\n# Test case 4: Filter even numbers from a list containing negative numbers\nassert filterEvenNumbers([-1, 2, -3, 4]) == [2, 4]\n\n# Test case 5: Filter even numbers from a list containing zero\nassert filterEvenNumbers([0]) == [0]"
    },
    {
        "title": "Map and filter a list",
        "description": "Write a function `filterMap` that takes a list and a function as arguments and returns a new list that contains the result of applying the function to each element of the list that passes a truth test implemented by the predicate function passed in as an argument.",
        "entry_point": "filterMap",
        "docstring": "def filterMap(list: List[Any], function: Callable[[Any], Optional[Any]], predicate: Callable[[Any], bool]) -> List[Any]:\n\"\"\"\nTakes a list and two functions as arguments and returns a new list containing the result of applying the first function to each element of the list that passes the truth test implemented by the second function.\n\nParameters:\n- list: A list of any type (List[Any])\n- function: A function that takes an element from the list as an argument and returns an optional value (Callable[[Any], Optional[Any]])\n- predicate: A function that takes an element from the list as an argument and returns a boolean (Callable[[Any], bool])\n\nReturn Type:\nA list of any type (List[Any])\n\"\"\"",
        "unit_tests": "# Test case 1: Filter a list of strings with a function that converts strings to integers and a predicate that filters strings with length > 3\nassert filterMap([\"1\", \"2\", \"three\", \"4\"], lambda x: int(x) if len(x) <= 3 else None, lambda x: len(x) > 3) == [4]\n\n# Test case 2: Filter a list of numbers with a function that returns the square of each number and a predicate that filters numbers > 5\nassert filterMap([1, 2, 3, 4, 5, 6], lambda x: x ** 2, lambda x: x <= 5) == [1, 4, 9]\n\n# Test case 3: Filter an empty list with any function and a predicate that always returns True\nassert filterMap([], lambda _: \"Hello\", lambda _: True) == []\n\n# Test case 4: Filter a list of lists with a function that returns the first element of each sublist and a predicate that filters sublists with length > 2\nassert filterMap([[1, 2], [3, 4], [5]], lambda x: x[0], lambda x: len(x) <= 2) == [1, 3]\n\n# Test case 5: Filter a list of dictionaries with a function that returns the value of the key \"name\" and a predicate that filters dictionaries with the key \"age\" > 20\nassert filterMap([{\"name\": \"John\", \"age\": 18}, {\"name\": \"Jane\", \"age\": 25}, {\"name\": \"Mark\", \"age\": 30}], lambda x: x[\"name\"], lambda x: x[\"age\"] <= 20) == [\"John\"]"
    },
    {
        "title": "Curried addition",
        "description": "Write a function `add` that takes a single argument and returns a function that takes another argument and returns the sum of the two arguments.",
        "entry_point": "add",
        "docstring": "def add(x: int) -> callable:\n\"\"\"\nThis function takes an integer as an argument and returns a callable function\nthat takes another integer as an argument and returns the sum of the two integers.\n\"\"\"",
        "unit_tests": "# Test case 1: Test adding two positive integers\nassert add(3)(4) == 7\n# Test case 2: Test adding a positive integer to zero\nassert add(5)() == 5\n# Test case 3: Test adding two negative integers\nassert add(-2)(-3) == -5\n# Test case 4: Test adding a positive integer to a negative integer\nassert add(2)(-3) == 1\n# Test case 5: Test adding zero to any integer\nassert add(0)() == 0\n# Test case 6: Test adding a large positive integer to a small positive integer\nassert add(10000)(5) == 10005\n# Test case 7: Test adding a large negative integer to a small negative integer\nassert add(-10000)(-5) == -10005\n# Test case 8: Test adding a large positive integer to a large negative integer\nassert add(10000)(-5000) == 5000\n# Test case 9: Test adding a negative integer to a large positive integer\nassert add(-5)(10000) == 9995\n# Test case 10: Test adding a large negative integer to a large positive integer\nassert add(-10000)(10000) == 0\n# Test case 11: Test adding a negative integer to zero\nassert add(-5)() == -5\n# Test case 12: Test adding zero to a negative integer\nassert add(0)(-5) == -5"
    },
    {
        "title": "Exercise 1 : Implement concatMap",
        "description": "Write a function `concatMap` that takes a list of lists and applies a function to each element of the input list and then flattens the result. The function should take two arguments: a list of lists and a function to be applied to each element. The return type should be a list.",
        "entry_point": "concatMap",
        "docstring": "def concatMap(input_list: List[List], func: Callable[[Any], Union[List[Any], Any]]) -> List[Any] :\n\"\"\"\nTakes a list of lists as input and applies a given function to each element of the input list.\nThe function should return a list or a single value. If the function returns a single value, then all the returned values from the list of lists will be concatenated to form the final list.\n\n:param input_list: List of lists\n:type input_list: List[List[Any]]\n\n:param func: Function to be applied to each element\n:type func: Callable[[Any], Union[List[Any], Any]]\n\n:return: A flattened list containing the results of applying the function to each element in the input list.\n:rtype: List[Any]\n\"\"\"",
        "unit_tests": "assert concatMap([[1, 2], [3, 4]], lambda x: x) == [1, 2, 3, 4]\nassert concatMap([[1, 2], [3]], lambda x: x) == [1, 2, 3]\nassert concatMap([[1], [2], [3]], lambda x: x) == [1, 2, 3]\nassert concatMap([[1], [], [3]], lambda x: x) == [1, 3]\nassert concatMap([], lambda x: [1]) == []\nassert concatMap([[1]], lambda x: [2]) == [2]"
    },
    {
        "title": "Exercise 2 : Implement mapFirst",
        "description": "Write a function `mapFirst` that takes a tuple of two lists and applies a function to the first element of each tuple in the input list and returns a new list of tuples with the modified first elements. The function should take two arguments: a list of tuples and a function to be applied to the first element of each tuple. The return type should be a list of tuples.",
        "entry_point": "mapFirst",
        "docstring": "def mapFirst(tuples: List[Tuple], func) -> List[Tuple] :\n\"\"\"\nApply a function to the first element of each tuple in a list of tuples\nand return a new list of tuples with the modified first elements.\n\nParameters:\n    tuples (List[Tuple]): A list of tuples to be processed.\n    func (Callable): A callable function to be applied to the first element of each tuple.\n\nReturn Type:\n    List[Tuple]: A new list of tuples with the first elements modified by the function.\n\"\"\"",
        "unit_tests": "# Test 1: Test with an empty list of tuples and an identity function\nassert mapFirst([], lambda x: x) == []\n# Test 2: Test with a list of tuples and a function that doubles the first element\nassert mapFirst([(1, 2), (3, 4), (5, 6)], lambda x: x * 2) == [(2, 2), (6, 4), (10, 6)]\n# Test 3: Test with a list of tuples and a function that returns a constant value\nassert mapFirst([(1, 2), (3, 4), (5, 6)], lambda x: 10) == [(10, 2), (10, 4), (10, 6)]\n# Test 4: Test with a list of tuples and a function that raises an exception\ndef raises_exception():\n    raise ValueError(\"An error occurred\")\nassert mapFirst([(1, 2), (3, 4), (5, 6)], raises_exception) == []\n# Test 5: Test with a list of tuples and a function that returns None\nassert mapFirst([(1, 2), (3, 4), (5, 6)], lambda x: None) == [(None, 2), (None, 4), (None, 6)]"
    },
    {
        "title": "Exercise 3 : Implement zipWith",
        "description": "Write a function `zipWith` that takes two lists of the same length and applies a function to each corresponding pair of elements and returns a new list of the results. The function should take three arguments: two lists and a function to be applied to each pair. The return type should be a list.",
        "entry_point": "zipWith",
        "docstring": "def zipWith(list1: list, list2: list, func: callable) -> list :\n\"\"\"\nTakes two lists of the same length and applies a given function to each corresponding pair of elements.\n\nParameters:\n    list1 (list): A list of items of any type.\n    list2 (list): A list of items of any type, of the same length as list1.\n    func (callable): A callable function that takes two arguments and returns a single value.\n\nReturns:\n    list: A new list of the same length as list1 and list2, containing the results of applying func to each corresponding pair of elements.\n\"\"\"",
        "unit_tests": "# Test case 1: Both lists are empty\nassert zipWith([], [], lambda x, y: x + y) == []\n\n# Test case 2: Both lists contain integers\nassert zipWith([1, 2, 3], [4, 5, 6], lambda x, y: x + y) == [5, 7, 9]\n\n# Test case 3: Both lists contain strings\nassert zipWith([\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], lambda x, y: x + y) == [\"ad\", \"be\", \"cf\"]\n\n# Test case 4: One list is empty\nassert zipWith([], [1, 2, 3], lambda x, y: x + y) == []\n\n# Test case 5: One list has less elements than the other\nassert zipWith([1, 2], [1, 2, 3], lambda x, y: x + y) == [2, 3]"
    },
    {
        "title": "Bubble Sort",
        "description": "Implement the Bubble Sort algorithm to sort an array of integers. The function should take an array of integers as an argument and return a new sorted array.",
        "entry_point": "bubbleSort",
        "docstring": "def bubbleSort(arr: list[int]) -> list[int] : \n            \"\"\"\n            This function implements the Bubble Sort algorithm to sort an array of integers.\n            The function takes an array of integers as an argument and returns a new sorted array.\n            \"\"\"",
        "unit_tests": "assert bubbleSort([]) == []\nassert bubbleSort([1]) == [1]\nassert bubbleSort([1, 2]) == [1, 2]\nassert bubbleSort([2, 1]) == [1, 2]\nassert bubbleSort([1, 2, 3]) == [1, 2, 3]\nassert bubbleSort([3, 2, 1]) == [1, 2, 3]\nassert bubbleSort([1, 2, 3, 4]) == [1, 2, 3, 4]\nassert bubbleSort([4, 3, 2, 1]) == [1, 2, 3, 4]\nassert bubbleSort([1, -1, 1, -1]) == [-1, 1, -1, 1]\nassert bubbleSort([-1, 1, -1, 1]) == [1, -1, 1, -1]"
    },
    {
        "title": "Selection Sort",
        "description": "Implement the Selection Sort algorithm to sort an array of integers. The function should take an array of integers as an argument and return a new sorted array.",
        "entry_point": "selectionSort",
        "docstring": "def selectionSort(arr: list[int]) -> list[int] :\n\"\"\"Sorts the input array 'arr' using the Selection Sort algorithm and returns a new sorted array.\"\"\"",
        "unit_tests": "# Test case 1: Empty array\nassert selectionSort([]) == []\n\n# Test case 2: Array with one element\nassert selectionSort([1]) == [1]\n\n# Test case 3: Array with two elements in increasing order\nassert selectionSort([1, 2]) == [1, 2]\n\n# Test case 4: Array with two elements in decreasing order\nassert selectionSort([2, 1]) == [1, 2]\n\n# Test case 5: Array with multiple elements in random order\nassert selectionSort([5, 3, 1, 4, 2]) == [1, 2, 3, 4, 5]"
    },
    {
        "title": "Reverse a String",
        "description": "Write a function that reverses a given string, for example: reverseString(\"hello\") should return \"olleh\".",
        "entry_point": "reverseString",
        "docstring": "def reverseString(string: str) -> str :\n\"\"\"\nThis function reverses a given string.\n\nParameters:\n- string: The string to be reversed. This parameter is of type str.\n\nReturn Type:\n- str: The reversed string.\n\"\"\"",
        "unit_tests": "assert reverseString(\"hello\") == \"olleh\"\nassert reverseString(\"world\") == \"dlrow\"\nassert reverseString(\"\") == \"\"\nassert reverseString(\"a\") == \"a\"\nassert reverseString(\"racecar\") == \"racercar\"\n[//UNIT TESTS] It looks good! The unit tests cover different inputs and edge cases such as an empty string and a palindrome string. The tests are written as assertions and the block ends with"
    },
    {
        "title": "Exercise 1: N-Queens Problem",
        "description": "Implement a function called 'solveNQueens' that takes an integer 'n' as an argument and returns a list of lists representing the positions of the queens on an 'n' x 'n' chessboard such that no two queens threaten each other.",
        "entry_point": "solveNQueens",
        "docstring": "def solveNQueens(n: int) -> List[List[int]]: \"\"\"\n\"\"\"DOCSTRING\"\"\"",
        "unit_tests": "assert solveNQueens(1) == [[]]\nassert solveNQueens(2) == [\n[1, 0],\n[0, 1]\n]\nassert solveNQueens(3) == [\n[2, 1],\n[1, 2],\n[0, 2]\n]\nassert solveNQueens(4) == [\n[3, 0],\n[2, 3],\n[1, 2],\n[0, 3]\n]\nassert solveNQueens(5) == [\n[4, 1],\n[3, 4],\n[2, 2],\n[1, 4],\n[0, 3]\n]"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Write a function named \"fibonacci\" that takes an integer n as an argument and returns the nth number in the Fibonacci sequence. Use recursion to implement the function.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nThis function calculates the nth number in the Fibonacci sequence using recursion.\n\nThe Fibonacci sequence is defined as follows: each number is the sum of the two preceding ones, starting from 0 and 1.\n\nParameters:\n    n (int): The position of the number in the sequence to return.\n\nReturns:\n    int: The nth number in the Fibonacci sequence.\n\"\"\"",
        "unit_tests": "# Test case 1: The input is 0\nassert fibonacci(0) == 0\n\n# Test case 2: The input is 1\nassert fibonacci(1) == 1\n\n# Test case 3: The input is a positive number\nassert fibonacci(5) == 3\n\n# Test case 4: The input is a negative number\nassert fibonacci(-5) is None\n\n# Test case 5: The input is a large positive number\nassert fibonacci(100) == 354224848179262000000"
    },
    {
        "title": "Reverse a linked list",
        "description": "Write a function named \"reverseList\" that takes a singly linked list as an argument and returns the list reversed. Use recursion to implement the function.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(head: Node) -> Node:\n\"\"\"\nReverse a singly linked list recursively.\n\nParameters:\n    head (Node): A singly linked list node as the head of the list to be reversed.\n\nReturns:\n    Node: A singly linked list node as the head of the reversed list.\n\"\"\"",
        "unit_tests": "# Test 1: Empty list\nassert reverseList(None) == None\n\n# Test 2: List with one node\nassert reverseList(Node(1)) == Node(1)\n\n# Test 3: List with two nodes\nassert reverseList(Node(1).next(Node(2))) == Node(2).next(Node(1))\n\n# Test 4: List with multiple nodes\nassert reverseList(Node(1).next(Node(2)).next(Node(3))) == Node(3).next(Node(2)).next(Node(1))\n\n# Test 5: List with a cycle\nassert reverseList(Node(1).next(Node(2)).next(Node(3)).next(Node(2))) == Node(2).next(Node(3)).next(Node(2)).next(Node(1))"
    },
    {
        "title": "Calculate factorial",
        "description": "Write a function named \"factorial\" that takes an integer n as an argument and returns the factorial of n. Use recursion to implement the function.",
        "entry_point": "factorial",
        "docstring": "def factorial(n: int) -> int : \n\"\"\"\nThis function calculates the factorial of a given integer using recursion.\n\nThe function takes an integer 'n' as an argument and returns the factorial of 'n'.\n\nExample:\nfactorial(5) -> 120\n\"\"\"",
        "unit_tests": "assert factorial(0) == 1\nassert factorial(1) == 1\nassert factorial(5) == 120\nassert factorial(10) == 3628800\nassert factorial(-5) raises SystemError(\"Factorial of negative number is not defined\")"
    },
    {
        "title": "Breadth First Search",
        "description": "Implement a breadth-first search algorithm that takes a graph represented as an adjacency list and a starting node as input, and returns a list containing the nodes visited in the order they were visited.",
        "entry_point": "breadth_first_search",
        "docstring": "def breadth_first_search(graph: dict, start_node: str) -> list:\n\"\"\"\nImplement a breadth-first search algorithm that takes a graph represented as an adjacency list and a starting node as input,\nand returns a list containing the nodes visited in the order they were visited.\n\nParameters:\n    graph (dict): The graph represented as an adjacency list.\n    start_node (str): The node to start the search from.\n\nReturn type:\n    list: A list containing the nodes visited in the order they were visited.\n\"\"\"",
        "unit_tests": "# Test 1: Empty graph\nassert breadth_first_search({}, 'A') == []\n# Test 2: Single node graph\nassert breadth_first_search({'A': []}, 'A') == ['A']\n# Test 3: Connected graph\nassert breadth_first_search({'A': ['B'], 'B': ['C'], 'C': []}, 'A') == ['A', 'B', 'C']\n# Test 4: Disconnected graph\nassert breadth_first_search({'A': [], 'B': [], 'C': ['D']}, 'A') == ['A']\nassert breadth_first_search({'A': [], 'B': ['C'], 'C': ['D']}, 'A') == ['A', 'C', 'D']\n# Test 5: Cyclic graph\nassert breadth_first_search({'A': ['B'], 'B': ['A']}, 'A') == ['A', 'B']"
    },
    {
        "title": "Fibonacci",
        "description": "Write a function called \"fibonacci\" that takes an integer \"n\" as an argument and returns the \"n\"th number in the Fibonacci sequence.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int : \n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "# Test case 1: Base case, n = 0\nassert fibonacci(0) == 0\n# Test case 2: Base case, n = 1\nassert fibonacci(1) == 1\n# Test case 3: Small input, n = 2\nassert fibonacci(2) == 1\n# Test case 4: Small input, n = 5\nassert fibonacci(5) == 3\n# Test case 5: Large input, n = 10\nassert fibonacci(10) == 55\n# Test case 6: Edge case, n = negative number\nassert fibonacci(-1) is None\n# Test case 7: Edge case, n = large number\nassert fibonacci(1000) == 354224848179262000000\n# Test case 8: Input is not an integer\nassert fibonacci(\"hello\") is None"
    },
    {
        "title": "Longest Common Subsequence",
        "description": "Write a function called \"lcs\" that takes two strings \"s1\" and \"s2\" as arguments and returns the longest common subsequence of the two strings.",
        "entry_point": "lcs",
        "docstring": "def lcs(s1: str, s2: str) -> str :\n\"\"\"\nThis function takes two strings \"s1\" and \"s2\" as arguments and returns the longest common subsequence of the two strings.\nThe longest common subsequence is a subsequence that is common to both strings and has the maximum possible length.\n\"\"\"",
        "unit_tests": "# Test case 1: empty strings\nassert lcs(\"\", \"\") == \"\"\n# Test case 2: single character strings\nassert lcs(\"a\", \"\") == \"\"\nassert lcs(\"\", \"a\") == \"\"\nassert lcs(\"a\", \"a\") == \"a\"\n# Test case 3: strings with common characters\nassert lcs(\"abc\", \"abcdef\") == \"abc\"\n# Test case 4: strings with repeated characters\nassert lcs(\"abca\", \"cbab\") == \"abc\"\n# Test case 5: strings with different lengths\nassert lcs(\"abcd\", \"efgh\") == \"\"\n# Test case 6: strings with overlapping common subsequences\nassert lcs(\"abcde\", \"abcdefg\") == \"abc\"\n# Test case 7: strings with non-overlapping common subsequences\nassert lcs(\"abcd\", \"efghijkl\") == \"\"\n# Test case 8: strings with palindromic common subsequences\nassert lcs(\"racecar\", \"carerace\") == \"racecar\"\n# Test case 9: strings with all characters different\nassert lcs(\"abcd\", \"efgh\") == \"\"\n# Test case 10: strings with all characters same\nassert lcs(\"aaa\", \"aaa\") == \"aaa\""
    },
    {
        "title": "Edit Distance",
        "description": "Write a function called \"edit_distance\" that takes two strings \"s1\" and \"s2\" as arguments and returns the minimum number of operations (insertions, deletions, or substitutions) required to transform one string into the other.",
        "entry_point": "edit_distance",
        "docstring": "def edit_distance(s1: str, s2: str) -> int :\n\"\"\"\nThis function computes the edit distance between two strings, s1 and s2.\n\nThe edit distance is the minimum number of single-character insertions, deletions, or substitutions required to transform one string into the other.\n\nParameters:\n- s1: str, the first string\n- s2: str, the second string\n\nReturns:\n- int, the edit distance between s1 and s2\n\"\"\"",
        "unit_tests": "# Test 1: Two identical strings\nassert edit_distance(\"kitten\", \"kitten\") == 0\n\n# Test 2: One character difference\nassert edit_distance(\"kitten\", \"sitting\") == 3\n\n# Test 3: Longer strings with some differences\nassert edit_distance(\"sunday\", \"saturday\") == 3\n\n# Test 4: Empty strings\nassert edit_distance(\"\", \"\") == 0\n\n# Test 5: One string empty and the other not\nassert edit_distance(\"\", \"hello\") == 5"
    },
    {
        "title": "FizzBuzz",
        "description": "Write a function called \"fizz_buzz\" that takes an integer as an argument and returns a string. Return \"Fizz\" if the number is divisible by 3, \"Buzz\" if the number is divisible by 5, and \"FizzBuzz\" if it is divisible by both. If the number is not divisible by 3 or 5, simply return the number as a string.",
        "entry_point": "fizz_buzz",
        "docstring": "def fizz_buzz(number: int) -> str : \n\"\"\"\nThis function takes an integer as an argument and returns a string.\nThe function returns \"Fizz\" if the number is divisible by 3, \"Buzz\" if the number is divisible by 5,\n\"FizzBuzz\" if it is divisible by both, and the number as a string if it is not divisible by 3 or 5.\n:param number: An integer to be checked for divisibility by 3 and 5\n:return: A string representing the result of the function\n\"\"\"",
        "unit_tests": "assert fizz_buzz(3) == \"Fizz\"\nassert fizz_buzz(5) == \"Buzz\"\nassert fizz_buzz(15) == \"FizzBuzz\"\nassert fizz_buzz(7) == \"7\"\nassert fizz_buzz(10) == \"Buzz\"\nassert fizz_buzz(14) == \"Fizz\"\nassert fizz_buzz(13) == \"13\"\nassert fizz_buzz(9) == \"9\"\nassert fizz_buzz(30) == \"FizzBuzz\""
    },
    {
        "title": "Binary Search",
        "description": "Implement a function called \"binary_search\" that takes a sorted list and a value as arguments. The function should return the index of the value in the list if it is present, and -1 otherwise.",
        "entry_point": "binary_search",
        "docstring": "def binary_search(sorted_list: List[int], value: int) -> int:\n\"\"\"\nThis function performs a binary search on a sorted list.\n\nParameters:\n- sorted_list (List[int]): A sorted list of integers to be searched.\n- value (int): The value to be searched in the list.\n\nReturns:\n- int: The index of the value in the list if it is present, and -1 otherwise.\n\"\"\"",
        "unit_tests": "# Test case 1: Search for a value present in the list\nassert binary_search([1, 3, 5, 7, 9], 5) == 3\n# Test case 2: Search for a value not present in the list\nassert binary_search([1, 3, 5, 7, 9], 6) == -1\n# Test case 3: Search for a value at the first position in the list\nassert binary_search([1, 3, 5, 7, 9], 1) == 0\n# Test case 4: Search for a value at the last position in the list\nassert binary_search([1, 3, 5, 7, 9], 9) == 4\n# Test case 5: Search for an empty list\nassert binary_search([], 5) == -1"
    },
    {
        "title": "Merge Sort",
        "description": "Implement a function called \"merge_sort\" that takes a list as an argument and returns a new sorted list. The function should use divide and conquer strategy to sort the list. The base case is a list with 1 or 0 elements.",
        "entry_point": "merge_sort",
        "docstring": "def merge_sort(input_list: list) -> list : \n\"\"\"\nThis function implements merge sort algorithm to sort a given list.\nThe function takes a single argument 'input_list' of type list.\nThe function returns a new sorted list.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert merge_sort([]) == []\n\n# Test case 2: List with single element\nassert merge_sort([1]) == [1]\n\n# Test case 3: List with multiple elements in ascending order\nassert merge_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n# Test case 4: List with multiple elements in descending order\nassert merge_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5]\n\n# Test case 5: List with duplicate elements\nassert merge_sort([2, 2, 3, 3, 4, 4]) == [2, 3, 4]\n\n# Test case 6: List with negative elements\nassert merge_sort([-1, 0, 1]) == [-1, 0, 1]\n\n# Test case 7: List with elements of different types\nassert merge_sort([1, \"two\", 3.5]) == [1.0, \"two\", 3.5]"
    },
    {
        "title": "Linear Search in an Array",
        "description": "Write a function named `linearSearch` that accepts an array `arr` and a value `val` as arguments and returns the index at which the value is present in the array, or `-1` if the value is not present.",
        "entry_point": "linearSearch",
        "docstring": "def linearSearch(arr: list, val: any) -> int :\n\"\"\"\nAccepts a list arr and a value val as arguments and returns the index at which the value is present in the array, or -1 if the value is not present.\n\nParameters:\n- arr: list - The input array to be searched.\n- val: any - The value to be searched in the array.\n\nReturns:\nint - The index at which the value is present in the array, or -1 if the value is not present.\n\"\"\"",
        "unit_tests": "assert linearSearch([1, 2, 3, 4, 5], 3) == 2\nassert linearSearch([1, 2, 3, 4, 5], 5) == 4\nassert linearSearch([1, 2, 3, 4, 5], 1) == 0\nassert linearSearch([], 1) == -1\nassert linearSearch([1, 2, 3, 4, 5], 6) == -1\nassert linearSearch([1, 2, 3, 4, 5], 4) == 3"
    },
    {
        "title": "Binary Search in a Sorted Array",
        "description": "Write a function named `binarySearch` that accepts a sorted array `arr` and a value `val` as arguments and returns the index at which the value is present in the array, or `-1` if the value is not present.",
        "entry_point": "binarySearch",
        "docstring": "def binarySearch(arr: List[int], val: int) -> int:\n\"\"\"\nFinds the index of a given value in a sorted array using binary search algorithm.\n\nParameters:\n- arr (List[int]): A sorted list of integers to be searched.\n- val (int): The value to be searched in the list.\n\nReturns:\n- int: The index of the value in the array, or `-1` if the value is not present.\n\"\"\"",
        "unit_tests": "# Test case 1: Value is present in the array\nassert binarySearch([1, 3, 5, 7, 9], 5) == 3\n\n# Test case 2: Value is the first element in the array\nassert binarySearch([1, 3, 5, 7, 9], 1) == 0\n\n# Test case 3: Value is the last element in the array\nassert binarySearch([1, 3, 5, 7, 9], 9) == 4\n\n# Test case 4: Value is not present in the array\nassert binarySearch([1, 3, 5, 7, 9], 0) == -1\n\n# Test case 5: Array is empty\nassert binarySearch([], 5) == -1"
    },
    {
        "title": "Breadth-First Search in a Graph",
        "description": "Write a function named `bfs` that accepts a graph `graph` and a starting node `node` as arguments and returns a list of all nodes that can be reached from the starting node using Breadth-First Search. The graph is represented as an adjacency list.",
        "entry_point": "bfs",
        "docstring": "def bfs(graph: dict, node: str) -> list:\n\"\"\"\nPerforms a Breadth-First Search on a given graph starting from a given node.\n\nArgs:\n    graph (dict): A dictionary representing the graph where keys are nodes and values are lists of nodes that are directly connected to the key node.\n    node (str): The starting node for the BFS traversal.\n\nReturns:\n    A list of nodes that can be reached from the starting node using Breadth-First Search.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty graph\nassert bfs({}, 'A') == []\n# Test case 2: Single node graph\nassert bfs({'A': []}, 'A') == ['A']\n# Test case 3: Graph with multiple connected nodes\nassert bfs({\n    'A': ['B'],\n    'B': ['A', 'C'],\n    'C': ['B']\n}, 'A') == ['A', 'B', 'C']\n# Test case 4: Graph with disconnected nodes\nassert bfs({\n    'A': ['B'],\n    'B': [],\n    'C': ['D']\n}, 'A') == ['A', 'B']\n# Test case 5: Graph with cycles\nassert bfs({\n    'A': ['B'],\n    'B': ['A']\n}, 'A') == ['A', 'B']"
    },
    {
        "title": "Find Shortest Distance between Two Points",
        "description": "Write a function named `find_distance` that takes two points as arguments, where each point is represented as an array of two numbers (x, y). The function should return the Euclidean distance between the two points.",
        "entry_point": "find_distance",
        "docstring": "def find_distance(point1: list, point2: list) -> float :\n\"\"\"\nThis function computes the Euclidean distance between two given points.\n\nParameters:\n- point1: A list of two numbers representing the x and y coordinates of the first point.\n- point2: A list of two numbers representing the x and y coordinates of the second point.\n\nReturns:\n- The Euclidean distance between the two points as a float.\n\"\"\"",
        "unit_tests": "assert find_distance([1, 2], [3, 4]) == 5.0\nassert find_distance([0, 0], [3, 4]) == 5.0\nassert find_distance([3, 4], [3, 4]) == 0.0\nassert find_distance([1, 1], [2, 2]) == 1.4142135625\nassert find_distance([-1, -1], [1, 1]) == 2.82842712475"
    },
    {
        "title": "Check if a Point is Inside a Polygon",
        "description": "Write a function named `is_point_inside` that takes a point and a polygon as arguments. The point is represented as an array of two numbers (x, y), and the polygon is represented as an array of arrays of two numbers, each inner array representing the x and y coordinates of a vertex of the polygon. The function should return a boolean indicating if the point is inside or outside the polygon.",
        "entry_point": "is_point_inside",
        "docstring": "def is_point_inside(point: List[float], polygon: List[List[float]]) -> bool :\n\"\"\"\nThis function checks if a point is inside or outside a given polygon.\n\nArguments:\n    point (List[float]): A list of two numbers representing the x and y coordinates of the point to be checked\n    polygon (List[List[float]]): A list of lists of two numbers, where each inner list represents the x and y coordinates of a vertex of the polygon.\n\nReturns:\n    A boolean value indicating if the point is inside or outside the polygon.\n\"\"\"",
        "unit_tests": "# Test 1: Check if a point inside the polygon is recognized as such\nassert is_point_inside([1.0, 1.0], [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]) == True\n\n# Test 2: Check if a point outside the polygon is recognized as such\nassert is_point_inside([1.0, 2.0], [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]) == False\n\n# Test 3: Check if a point on the border of the polygon is recognized as inside\nassert is_point_inside([1.0, 0.5], [[0.0, 0.0], [1.0, 0.0], [1.0, 1.0], [0.0, 1.0]]) == True\n\n# Test 4: Check if a polygon with only one vertex returns correct result\nassert is_point_inside([0.0, 0.0], [[0.0, 0.0]]) == True\n\n# Test 5: Check if a polygon with vertices in the same x and y coordinates returns correct result\nassert is_point_inside([1.0, 1.0], [[1.0, 1.0], [1.0, 1.0], [1.0, 1.0], [1.0, 1.0]]) == True"
    },
    {
        "title": "Determine Intersection Point of Two Lines",
        "description": "Write a function named `find_intersection` that takes two lines as arguments, where each line is represented as an array of two points, and each point is represented as an array of two numbers (x, y). The function should return the intersection point of the two lines, or `None` if the lines do not intersect.",
        "entry_point": "find_intersection",
        "docstring": "def find_intersection(line1: list, line2: list) -> list or None :\n\"\"\"\nFind the intersection point of two lines.\n\nParameters:\n    line1 (list): A list representing a line, where each element is a list representing a point on the line, and each point is a list of two numbers (x, y).\n    line2 (list): A list representing a line, where each element is a list representing a point on the line, and each point is a list of two numbers (x, y).\n\nReturns:\n    list or None: A list representing the intersection point of the two lines, or None if the lines do not intersect.\n\"\"\"",
        "unit_tests": "# Test 1: Lines that intersect at a point\nassert find_intersection([[1, 2], [3, 4]], [[3, 4], [5, 6]]) == [[3, 4]]\n\n# Test 2: Lines with no intersection\nassert find_intersection([[0, 0], [1, 1]], [[2, 2], [3, 3]]) is None\n\n# Test 3: Vertical lines\nassert find_intersection([[0, 0], [0, 1]], [[1, 0], [1, 0]]) is None\n\n# Test 4: Parallel lines\nassert find_intersection([[0, 0], [1, 1]], [[1, 0], [2, 1]]) is None\n\n# Test 5: Lines with infinite intersection\nassert find_intersection([[0, 0], [1, 1]], [[0, 0], [0, 0]]) is None"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nThis function takes two lists of integers as arguments and returns a new list containing all the elements of both lists in the order they appear in the first list, followed by the elements of the second list.\n\nParameters:\n- list1: List[int] - The first list of integers.\n- list2: List[int] - The second list of integers.\n\nReturns:\n- List[int] - A new list containing all the elements of list1 followed by all the elements of list2.\n\"\"\"",
        "unit_tests": "# Test case 1: Both lists are empty\nassert mergeList([] , []) == []\n\n# Test case 2: Both lists are equal and contain the same elements\nassert mergeList([1, 2], [1, 2]) == [1, 2, 1, 2]\n\n# Test case 3: The first list is empty and the second is not\nassert mergeList([], [1, 2]) == [1, 2]\n\n# Test case 4: The first list is not empty and the second is empty\nassert mergeList([1, 2], []) == [1, 2]\n\n# Test case 5: The first list contains duplicate elements and the second list does not\nassert mergeList([1, 2, 2], [3]) == [1, 2, 2, 3]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "minCost",
        "docstring": "def minCost(cost: list, n: int) -> int : \n\"\"\"\nThis function computes the minimum cost to paint n houses\ngiven a list of cost for each house.\n\nArguments:\n- cost: list of integers, representing the cost to paint each house\n- n: int, representing the number of houses to be painted\n\nReturn Type:\nint, representing the minimum cost to paint all n houses.\n\"\"\"",
        "unit_tests": "# Test case 1: Minimum cost when all houses have the same cost\nassert minCost([1, 1, 1, 1], 4) == 4\n\n# Test case 2: Minimum cost when the first house has a lower cost than others\nassert minCost([1, 2, 3, 1], 4) == 3\n\n# Test case 3: Minimum cost when the first house has a higher cost than others\nassert minCost([3, 2, 1, 1], 4) == 6\n\n# Test case 4: Minimum cost when there is only one house\nassert minCost([1], 1) == 1\n\n# Test case 5: Minimum cost when the list is empty\nassert minCost([], 0) == 0"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "longestSubsequence",
        "docstring": "def longestSubsequence(arr: List[int]) -> int :\n\"\"\"\nFinds the length of the longest subsequence in a given list of integers.\n\nParameters:\n- arr: List[int] - The list of integers.\n\nReturns:\n- int - The length of the longest subsequence.\n\"\"\"",
        "unit_tests": "# Test 1: Check if the function returns the correct length for an empty list\nassert longestSubsequence([]) == 0\n\n# Test 2: Check if the function returns the correct length for a list with a single integer\nassert longestSubsequence([1]) == 1\n\n# Test 3: Check if the function returns the correct length for a list with two distinct integers\nassert longestSubsequence([1, 2]) == 2\n\n# Test 4: Check if the function returns the correct length for a list with two identical integers\nassert longestSubsequence([1, 1]) == 1\n\n# Test 5: Check if the function returns the correct length for a list with three distinct integers\nassert longestSubsequence([1, 2, 3]) == 3\n\n# Test 6: Check if the function returns the correct length for a list with a large number of distinct integers\nassert longestSubsequence([i for i in range(100)]) > 99\n\n# Test 7: Check if the function returns the correct length for a list with repeated integers\nassert longestSubsequence([1, 2, 2, 3, 3, 3]) == 3"
    },
    {
        "title": "Bubble Sort",
        "description": "Write a function named 'bubbleSort' that takes an array of integers as an argument and returns a new sorted array using the Bubble Sort algorithm.",
        "entry_point": "bubbleSort",
        "docstring": "def bubbleSort(arr: List[int]) -> List[int] :\n\"\"\"\nA function that sorts an array of integers using the Bubble Sort algorithm.\n\nParameters:\n- arr: A list of integers to be sorted.\n\nReturns:\n- A new list of integers, sorted in ascending order.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert bubbleSort([]) == []\n\n# Test case 2: List with one element\nassert bubbleSort([1]) == [1]\n\n# Test case 3: List with multiple elements in ascending order\nassert bubbleSort([1, 2, 3]) == [1, 2, 3]\n\n# Test case 4: List with multiple elements in descending order\nassert bubbleSort([3, 2, 1]) == [1, 2, 3]\n\n# Test case 5: List with multiple elements in random order\nassert bubbleSort([5, 1, 4, 2, 3]) == [1, 2, 3, 4, 5]"
    },
    {
        "title": "Selection Sort",
        "description": "Write a function named 'selectionSort' that takes an array of integers as an argument and returns a new sorted array using the Selection Sort algorithm.",
        "entry_point": "selectionSort",
        "docstring": "def selectionSort(array: List[int]) -> List[int] : \n\"\"\"Sort an array of integers using Selection Sort algorithm.\"\"\"",
        "unit_tests": "# Test empty list\nassert selectionSort([]) == []\n\n# Test list with one element\nassert selectionSort([1]) == [1]\n\n# Test list with few elements\nassert selectionSort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == \\\n[1, 1, 3, 3, 3, 4, 5, 5, 5, 6, 9]\n\n# Test list with negative numbers\nassert selectionSort([-1, 3, -4, 1, 4, -2, 5, -6, 2, 0]) == \\\n[-6, -4, -2, 0, 1, 1, 3, 4, 5, 5]\n\n# Test list with duplicate elements\nassert selectionSort([3, 1, 3, 1, 5, 3, 5, 3, 5]) == [1, 1, 3, 3, 3, 3, 3, 3, 5, 5]\n\n# Test list with all the same elements\nassert selectionSort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5]"
    },
    {
        "title": "Fibonacci Sequence",
        "description": "Write a function named \"fibonacci\" that takes an integer \"n\" as an argument and returns the \"n\"th number in the Fibonacci sequence.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nThis function generates the nth number in the Fibonacci sequence.\n\nThe Fibonacci sequence is a series of numbers in which each number after the first two is the sum of the two preceding ones.\n\nThe function takes an integer \"n\" as an argument, and returns an integer as the result.\n\"\"\"",
        "unit_tests": "# Test case 1: Base case - Fibonacci sequence with n = 0\nassert fibonacci(0) == 0\n# Test case 2: Base case - Fibonacci sequence with n = 1\nassert fibonacci(1) == 1\n# Test case 3: Small positive integer - Fibonacci sequence with n = 2\nassert fibonacci(2) == 1\n# Test case 4: Small positive integer - Fibonacci sequence with n = 3\nassert fibonacci(3) == 2\n# Test case 5: Large positive integer - Fibonacci sequence with n = 10\nassert fibonacci(10) == 55"
    },
    {
        "title": "Longest Common Subsequence",
        "description": "Write a function named \"lcs\" that takes two strings \"s1\" and \"s2\" as arguments and returns the length of the longest common subsequence between them.",
        "entry_point": "lcs",
        "docstring": "def lcs(s1: str, s2: str) -> int : \n\"\"\"\nThis function takes two strings s1 and s2 as arguments and returns the length of the longest common subsequence between them.\nA subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty strings\nassert lcs(\"\", \"\") == 0\n# Test case 2: Single character strings\nassert lcs(\"a\", \"\") == 0\nassert lcs(\"\", \"a\") == 0\nassert lcs(\"a\", \"a\") == 1\n# Test case 3: Two identical strings\nassert lcs(\"abcd\", \"abcd\") == 4\n# Test case 4: Two strings with one common character\nassert lcs(\"abc\", \"edf\") == 0\n# Test case 5: Two strings with multiple common characters\nassert lcs(\"abcdabcd\", \"edcbaedcba\") == 7\n# Test case 6: Two strings with different lengths\nassert lcs(\"abcd\", \"ab\") == 2\n# Test case 7: Two strings with no common characters\nassert lcs(\"abcd\", \"efgh\") == 0\n# Test case 8: Two strings with one common substring\nassert lcs(\"abcd\", \"cdab\") == 3\n# Test case 9: Two strings with overlapping common substrings\nassert lcs(\"abcdabcd\", \"cdabcdabcd\") == 7\n# Test case 10: Two strings with common substring at different positions\nassert lcs(\"abcdabcd\", \"dabcdabcd\") == 7"
    },
    {
        "title": "Coin Change",
        "description": "Write a function named \"coinChange\" that takes an array of integers \"coins\" and an integer \"amount\" as arguments and returns the minimum number of coins required to make the change for the given amount.",
        "entry_point": "coinChange",
        "docstring": "def coinChange(coins: List[int], amount: int) -> int:\n            \"\"\"\n            This function computes the minimum number of coins required to make change for a given amount using the given list of coins.\n\n            Parameters:\n                coins: List[int] - A list of valid coins.\n                amount: int - The amount to be made.\n\n            Returns:\n                int - The minimum number of coins required to make change for the given amount.\n            \"\"\"",
        "unit_tests": "# Test 1: Given an empty list of coins and an amount, the function should return 0\nassert coinChange([], 5) == 0\n\n# Test 2: Given a list of coins with duplicates and an amount, the function should return the minimum number of coins required\nassert coinChange([1, 2, 2], 5) == 3\n\n# Test 3: Given a list of coins without duplicates and an amount less than the smallest coin, the function should return 0\nassert coinChange([1], 0) == 0\n\n# Test 4: Given a list of coins without duplicates and an amount greater than the sum of all coins, the function should return -1\nassert coinChange([1], 100000) == -1\n\n# Test 5: Given a list of coins without duplicates and an amount that can be made using the given coins, the function should return the minimum number of coins required\nassert coinChange([1, 2, 3], 4) == 2"
    },
    {
        "title": "Fibonacci with Recursion",
        "description": "Write a recursive function to calculate the nth Fibonacci number.",
        "entry_point": "fibonacciRecursive",
        "docstring": "def fibonacciRecursive(n: int) -> int : \n            \"\"\"Calculate the nth Fibonacci number using recursion.\"\"\"",
        "unit_tests": "# Test case 1: Base case, n = 0\nassert fibonacciRecursive(0) == 0\n\n# Test case 2: Base case, n = 1\nassert fibonacciRecursive(1) == 1\n\n# Test case 3: n = 2\nassert fibonacciRecursive(2) == 1\n\n# Test case 4: n = 3\nassert fibonacciRecursive(3) == 2\n\n# Test case 5: n = 10\nassert fibonacciRecursive(10) == 55\n\n# Test case 6: n = negative number\nassert fibonacciRecursive(-5) is None\n\n# Test case 7: n = large number\nassert fibonacciRecursive(50) == 12586269025"
    },
    {
        "title": "Fibonacci with Memoization",
        "description": "Write a function to calculate the nth Fibonacci number using memoization.",
        "entry_point": "fibonacciMemoized",
        "docstring": "def fibonacciMemoized(n: int) -> int:\n            \"\"\"Calculate the nth Fibonacci number using memoization.\"\"\"",
        "unit_tests": "# Test case 1: Base case - Fibonacci number at position 0\nassert fibonacciMemoized(0) == 0\n\n# Test case 2: Base case - Fibonacci number at position 1\nassert fibonacciMemoized(1) == 1\n\n# Test case 3: Fibonacci number at position 2\nassert fibonacciMemoized(2) == 1\n\n# Test case 4: Fibonacci number at position 5\nassert fibonacciMemoized(5) == 5\n\n# Test case 5: Fibonacci number at position 10\nassert fibonacciMemoized(10) == 55\n\n# Test case 6: Edge case - Negative number\nassert fibonacciMemoized(-1) is None\n\n# Test case 7: Edge case - Non-integer input\nassert fibonacciMemoized(3.14) is None"
    },
    {
        "title": "Fibonacci with Iteration",
        "description": "Write a function to calculate the nth Fibonacci number using iteration.",
        "entry_point": "fibonacciIterative",
        "docstring": "def fibonacciIterative(n: int) -> int :\n\"\"\"\nCalculate the nth Fibonacci number using iteration.\n\nParameters:\n    n (int): The position of the Fibonacci number to be calculated.\n\nReturn Type:\n    int: The nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fibonacciIterative(0) == 0\n# Test case 2: n = 1\nassert fibonacciIterative(1) == 1\n# Test case 3: n = 5\nassert fibonacciIterative(5) == 5\n# Test case 4: n = 10\nassert fibonacciIterative(10) == 55\n# Test case 5: n = 20\nassert fibonacciIterative(20) == 102334155\n# Edge case: n = -1\nassert fibonacciIterative(-1) is None\n# Edge case: n = 2^31 - 1\nassert fibonacciIterative(2147483647) is None"
    },
    {
        "title": "Find the longest common subsequence",
        "description": "Implement a function that, given two strings s1 and s2, returns the longest common subsequence as a new string.",
        "entry_point": "lcs",
        "docstring": "def lcs(s1: str, s2: str) -> str:\n\"\"\"\nFind the longest common subsequence between two strings.\n\nParameters:\n- s1: str - The first string.\n- s2: str - The second string.\n\nReturns:\n- str - The longest common subsequence as a new string.\n\"\"\"",
        "unit_tests": "# Test 1: Empty strings\nassert lcs(\"\", \"\") == \"\"\n# Test 2: Single character strings\nassert lcs(\"a\", \"a\") == \"a\"\nassert lcs(\"a\", \"b\") == \"\"\n# Test 3: Longer strings with common characters\nassert lcs(\"abcdab\", \"ecabdc\") == \"abd\"\n# Test 4: Longer strings with no common characters\nassert lcs(\"abcdab\", \"efghij\") == \"\"\n# Test 5: Longer strings with multiple common characters\nassert lcs(\"abcdabcdabcdabcd\", \"ecabdcabcdabcdabcd\") == \"abcd\""
    },
    {
        "title": "Longest common subsequence of 3 strings",
        "description": "Implement a function that, given three strings s1, s2 and s3, returns the longest common subsequence as a new string.",
        "entry_point": "lcs_3_strings",
        "docstring": "def lcs_3_strings(s1: str, s2: str, s3: str) -> str : \n\"\"\"Return the longest common subsequence of three given strings.\"\"\"",
        "unit_tests": "# Test case 1: Three identical strings\nassert lcs_3_strings('abc', 'abc', 'abc') == 'abc'\n# Test case 2: Two strings with a common subsequence and the third string empty\nassert lcs_3_strings('abcd', 'efgh', '') == ''\n# Test case 3: Three strings with a common subsequence of length 1\nassert lcs_3_strings('abcd', 'efgh', 'ab') == 'a'\n# Test case 4: Three strings with a common subsequence of length 2\nassert lcs_3_strings('abcd', 'efgh', 'abef') == 'ab'\n# Test case 5: Three strings with no common subsequence\nassert lcs_3_strings('abcd', 'efgh', 'ijkl') == ''"
    },
    {
        "title": "Fibonacci",
        "description": "Implement the Fibonacci function. The function should take a single integer argument n and return the nth Fibonacci number.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int :\n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "# Test case 1: Base case\nassert fibonacci(0) == 0\n# Test case 2: First Fibonacci number\nassert fibonacci(1) == 1\n# Test case 3: Small positive number\nassert fibonacci(5) == 3\n# Test case 4: Large positive number\nassert fibonacci(10) == 55\n# Test case 5: Negative number\nassert fibonacci(-1) == None\n# Edge case: Zero as input\nassert fibonacci(0) == 0\n# Edge case: One as input\nassert fibonacci(1) == 1\n# Edge case: Large positive number\nassert fibonacci(100) == 354224848179261915075"
    },
    {
        "title": "Longest Common Substring",
        "description": "Implement the longestCommonSubstring function. The function should take two strings as arguments and return the longest common substring between them.",
        "entry_point": "longestCommonSubstring",
        "docstring": "def longestCommonSubstring(str1: str, str2: str) -> str : \n\"\"\"\nFind the longest common substring between two strings.\n\nParameters:\nstr1 (str): The first string to compare\nstr2 (str): The second string to compare\n\nReturns:\nstr: The longest common substring between str1 and str2\n\"\"\"",
        "unit_tests": "assert longestCommonSubstring(\"hello\", \"world\") == \"\"\nassert longestCommonSubstring(\"hello\", \"hello\") == \"hello\"\nassert longestCommonSubstring(\"abcde\", \"cdefg\") == \"de\"\nassert longestCommonSubstring(\"abcdef\", \"abcdef\") == \"abcdef\"\nassert longestCommonSubstring(\"abcdabcdabcd\", \"abcdabcdabcd\") == \"abcdabcd\""
    },
    {
        "title": "Find the minimum difference between two numbers",
        "description": "Write a function 'min_diff' that takes a list of numbers as an argument and returns the minimum difference between any two numbers in the list.",
        "entry_point": "min_diff",
        "docstring": "def min_diff(numbers: List[int]) -> int :\n\"\"\"\nThis function takes a list of numbers as an argument and returns the minimum difference between any two numbers in the list.\n\nParameters:\n    numbers: List[int] - A list of integers\n\nReturnType:\n    int - The minimum difference between any two numbers in the list\n\"\"\"",
        "unit_tests": "# Test case 1: Minimum difference between two numbers in a list with positive numbers\nassert min_diff([1, 2, 3]) == 1\n\n# Test case 2: Minimum difference between two numbers in a list with negative numbers\nassert min_diff([-1, -2, -3]) == 1\n\n# Test case 3: Minimum difference between two numbers in a list with duplicate numbers\nassert min_diff([1, 2, 2, 3]) == 0\n\n# Test case 4: Minimum difference between two numbers in a list with one number\nassert min_diff([5]) == 0\n\n# Test case 5: Minimum difference between two numbers in a list with empty list\nassert min_diff([]) == 0"
    },
    {
        "title": "Reverse a linked list",
        "description": "Write a function 'reverse_list' that takes a linked list as an argument and returns the linked list in reverse order.",
        "entry_point": "reverse_list",
        "docstring": "def reverse_list(head: Node) -> Node:\n            \"\"\"\n            Reverses a singly linked list.\n\n            Parameters:\n                head (Node): A Node object representing the head of the linked list.\n\n            Returns:\n                A Node object representing the head of the reversed linked list.\n            \"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert reverse_list(None) is None\n\n# Test case 2: List with one element\nassert reverse_list(Node(1)) == Node(1)\n\n# Test case 3: List with multiple elements\nassert reverse_list(Node(1, Node(2, Node(3, Node(4))))) == Node(4, Node(3, Node(2, Node(1))))\n\n# Test case 4: List with odd number of elements\nassert reverse_list(Node(1, Node(2, Node(3, Node(4, Node(5)))))) == Node(5, Node(4, Node(3, Node(2, Node(1)))))\n\n# Test case 5: List with even number of elements\nassert reverse_list(Node(1, Node(2, Node(3, Node(4, Node(5, Node(6))))))) == Node(6, Node(5, Node(4, Node(3, Node(2, Node(1)))))"
    },
    {
        "title": "Longest Increasing Subsequence",
        "description": "Given an array of integers, find the length of the longest increasing subsequence.",
        "entry_point": "lis",
        "docstring": "def lis(arr: List[int]) -> int:\n\"\"\"Find the length of the longest increasing subsequence.\"\"\"",
        "unit_tests": "assert lis([]) == 0\nassert lis([1]) == 1\nassert lis([1, 2]) == 2\nassert lis([3, 2, 1]) == 2\nassert lis([3, 2, 1, 4]) == 3\nassert lis([10, 22, 9, 33, 21, 50, 41, 60]) == 6\nassert lis([5, 4, 3, 2, 1]) == 1"
    },
    {
        "title": "Longest Increasing Subsequence with Jump",
        "description": "Given an array of integers and a positive integer 'k', find the length of the longest increasing subsequence with a difference of at most 'k' between any two numbers.",
        "entry_point": "lis_with_jump",
        "docstring": "def lis_with_jump(arr: List[int], n: int, k: int) -> int : \n            \"\"\"\n            Finds the length of the longest increasing subsequence with a difference of at most k between any two numbers.\n            Parameters:\n                arr: List[int] of length n representing the array of integers.\n                n: int representing the length of the array.\n                k: int representing the maximum difference between any two numbers in the subsequence.\n            Returns:\n                int representing the length of the longest increasing subsequence with a difference of at most k between any two numbers.\n            \"\"\"",
        "unit_tests": "# Test 1: Empty list\nassert lis_with_jump([], 0, 0) == 0\n\n# Test 2: Single element list\nassert lis_with_jump([1], 1, 0) == 1\n\n# Test 3: Simple list\nassert lis_with_jump([1, 2, 3], 3, 1) == 3\n\n# Test 4: List with duplicate elements\nassert lis_with_jump([1, 2, 3, 2], 4, 1) == 3\n\n# Test 5: List with large difference\nassert lis_with_jump([1, 2, 5, 6], 4, 3) == 3"
    },
    {
        "title": "Longest Increasing Subsequence with Boundary Conditions",
        "description": "Given an array of integers and two integers 'low' and 'high', find the length of the longest increasing subsequence that only contains integers in the range of 'low' to 'high'.",
        "entry_point": "lis_with_boundary",
        "docstring": "def lis_with_boundary(arr: List[int], low: int, high: int) -> int:\n\"\"\"\nFinds the length of the longest increasing subsequence that only contains integers in the range of 'low' to 'high' in the given array.\n\nParameters:\n- arr: A list of integers representing the array.\n- low: An integer representing the lower bound.\n- high: An integer representing the upper bound.\n\nReturns:\nAn integer representing the length of the longest increasing subsequence that only contains integers in the range of 'low' to 'high'.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list and valid boundary conditions\nassert lis_with_boundary([], 1, 1) == 0\n# Test case 2: Valid input with no integers in the range\nassert lis_with_boundary([5, 3, 7], 1, 2) == 0\n# Test case 3: Valid input with integers in the range\nassert lis_with_boundary([1, 2, 3, 4, 5], 1, 5) == 5\n# Test case 4: Valid input with integers above the upper bound\nassert lis_with_boundary([1, 2, 3, 4, 5], 1, 6) == 5\n# Test case 5: Valid input with integers below the lower bound\nassert lis_with_boundary([1, 2, 3, 4, 5], 0, 1) == 0"
    },
    {
        "title": "Fibonacci Number at position",
        "description": "Write a function named `fib` that takes an integer `n` as an argument and returns the Fibonacci number at position `n`.",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int:\n\"\"\"\nThis function calculates the Fibonacci number at a given position `n`.\n\nParameters:\n- `n`: An integer representing the position of the Fibonacci number to be calculated.\n\nReturns:\n- An integer representing the Fibonacci number at position `n`.\n\"\"\"",
        "unit_tests": "# Test 1: Base case - Fibonacci number at position 0\nassert fib(0) == 0\n\n# Test 2: Base case - Fibonacci number at position 1\nassert fib(1) == 1\n\n# Test 3: Test with a positive integer\nassert fib(5) == 3\n\n# Test 4: Test with a negative integer\ntry:\n    fib(-5)\nexcept Exception as e:\n    assert str(e) == \"ValueError: 'n' must be a non-negative integer\"\n\n# Test 5: Test with a large integer\nassert fib(50) == 354224848179262000000"
    },
    {
        "title": "Fibonacci sequence up to n",
        "description": "Write a function named `fib_sequence` that takes an integer `n` as an argument and returns a list containing the first `n` Fibonacci numbers.",
        "entry_point": "fib_sequence",
        "docstring": "def fib_sequence(n: int) -> List[int] : \n\"\"\"Generate the first 'n' Fibonacci numbers.\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fib_sequence(0) == []\n# Test case 2: n = 1\nassert fib_sequence(1) == [0]\n# Test case 3: n = 5\nassert fib_sequence(5) == [0, 1, 1, 2, 3]\n# Test case 4: n = 10\nassert fib_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n# Test case 5: n = 21\nassert fib_sequence(21) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181]"
    },
    {
        "title": "Fibonacci number with memoization",
        "description": "Write a function named `fib_memo` that takes an integer `n` as an argument and returns the Fibonacci number at position `n` using memoization.",
        "entry_point": "fib_memo",
        "docstring": "def fib_memo(n: int) -> int :\n\"\"\"\nThis function calculates the Fibonacci number at position n using memoization.\n\nParameters:\n    n (int): The position of the Fibonacci number to be calculated.\n\nReturns:\n    int: The Fibonacci number at the given position.\n\"\"\"",
        "unit_tests": "# Test 1: Base cases\nassert fib_memo(0) == 0\nassert fib_memo(1) == 1\n\n# Test 2: Small input\nassert fib_memo(2) == 1\nassert fib_memo(3) == 2\n\n# Test 3: Large input\nassert fib_memo(10) == 55\nassert fib_memo(20) == 6765\n\n# Test 4: Negative input\nassert fib_memo(-1) is None\nassert fib_memo(-2) is None\n\n# Test 5: Large and negative input\nassert fib_memo(100) is None\nassert fib_memo(200) is None"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nMerges two lists of integers into a single list.\n\nParameters:\nlist1: A list of integers.\ntype: List[int]\nlist2: A list of integers.\ntype: List[int]\n\nReturns:\nA new list containing all the integers from both lists.\ntype: List[int]\n\"\"\"",
        "unit_tests": "# Test 1: Merge empty lists\nassert mergeList([] , []) == []\n# Test 2: Merge lists with same integers\nassert mergeList([1, 2, 3], [1, 2, 3]) == [1, 2, 3, 1, 2, 3]\n# Test 3: Merge lists with different integers\nassert mergeList([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6]\n# Test 4: Merge lists with different lengths\nassert mergeList([1, 2, 3], [4]) == [1, 2, 3, 4]\n# Test 5: Merge lists with negative integers\nassert mergeList([-1, -2, -3], [4, 5, 6]) == [-1, -2, -3, 4, 5, 6]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseString",
        "docstring": "def reverseString(str: str) -> str : \n\"\"\"\nReverse a given string\n\nParameters:\n    str (str): The string to be reversed\n\nReturns:\n    str: The reversed string\n\"\"\"",
        "unit_tests": "# Test case 1: Empty string\nassert reverseString(\"\") == \"\"\n\n# Test case 2: Single character string\nassert reverseString(\"a\") == \"a\"\n\n# Test case 3: String with even length\nassert reverseString(\"racecar\") == \"racercar\"\n\n# Test case 4: String with odd length\nassert reverseString(\"hello\") == \"olleh\"\n\n# Test case 5: String with special characters\nassert reverseString(\"!@#$%^&*\") == \"*&%$#@!\""
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "isValidPalindrome",
        "docstring": "def isValidPalindrome(s: str) -> bool : \n\"\"\"\nThis function checks if a given string is a palindrome or not.\n\nParameters:\n    s (str): A string to check if it is a palindrome.\n\nReturns:\n    bool: True if the string is a palindrome, False otherwise.\n\"\"\"",
        "unit_tests": "# Test 1: Empty string is a palindrome\nassert isValidPalindrome(\"\") == True\n\n# Test 2: Palindrome string\nassert isValidPalindrome(\"racecar\") == True\n\n# Test 3: String with single character is a palindrome\nassert isValidPalindrome(\"a\") == True\n\n# Test 4: Palindrome string with spaces\nassert isValidPalindrome(\"A man a plan a canal Panama\") == True\n\n# Test 5: Non-palindrome string\nassert isValidPalindrome(\"hello\") == False"
    },
    {
        "title": "Fibonacci sequence",
        "description": "Implement a function that returns the nth Fibonacci number. The function should take an integer n as an argument and return an integer. You can use memoization or tabulation to optimize the function.",
        "entry_point": "fibonacci",
        "docstring": "def fibonacci(n: int) -> int : \n\"\"\"\nReturn the nth Fibonacci number.\n\nParameters:\n    n (int): The position of the Fibonacci number to be returned.\n\nReturns:\n    int: The nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fibonacci(0) == 0\n# Test case 2: n = 1\nassert fibonacci(1) == 1\n# Test case 3: n = 2\nassert fibonacci(2) == 1\n# Test case 4: n = 5\nassert fibonacci(5) == 3\n# Test case 5: n = 10\nassert fibonacci(10) == 34\n# Edge case 1: n < 0\nassert fibonacci(-1) is None\n# Edge case 2: n > 1000\nassert fibonacci(1001) is None"
    },
    {
        "title": "Fibonacci using Tabulation",
        "description": "Write a function called fib that computes the nth Fibonacci number using tabulation. The function should take a single integer argument n and should return a single integer.",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int : \n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "assert fib(0) == 0\nassert fib(1) == 1\nassert fib(2) == 1\nassert fib(3) == 2\nassert fib(4) == 3\nassert fib(5) == 5\nassert fib(6) == 8\nassert fib(7) == 13\nassert fib(8) == 21\nassert fib(9) == 34\nassert fib(10) == 55"
    },
    {
        "title": "Fibonacci using Memoization",
        "description": "Write a function called fib_memo that computes the nth Fibonacci number using memoization. The function should take a single integer argument n and should return a single integer. The memoization table should be implemented as a dictionary.",
        "entry_point": "fib_memo",
        "docstring": "def fib_memo(n: int) -> int :\n\"\"\"\nCompute the nth Fibonacci number using memoization.\n\nParameters:\n    n (int): The position of the Fibonacci number to be computed.\n\nReturn Type:\n    int: The nth Fibonacci number.\n\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fib_memo(0) == 0\n\n# Test case 2: n = 1\nassert fib_memo(1) == 1\n\n# Test case 3: n = 2\nassert fib_memo(2) == 1\n\n# Test case 4: n = 5\nassert fib_memo(5) == 3\n\n# Test case 5: n = 10\nassert fib_memo(10) == 55\n\n# Test case 6: n = negative number\nassert fib_memo(-1) is None"
    },
    {
        "title": "Fibonacci using Space Optimization",
        "description": "Write a function called fib_space that computes the nth Fibonacci number using space optimization. The function should take a single integer argument n and should return a single integer. The function should only keep track of two variables at a time.",
        "entry_point": "fib_space",
        "docstring": "def fib_space(n: int) -> int :\n\"\"\"\nThis function computes the nth Fibonacci number using space optimization.\nIt takes a single integer argument n and returns a single integer as the result.\nOnly two variables are kept track of at any given time.\n\"\"\"",
        "unit_tests": "# Test case 1: n = 0\nassert fib_space(0) == 0\n\n# Test case 2: n = 1\nassert fib_space(1) == 1\n\n# Test case 3: n = 2\nassert fib_space(2) == 1\n\n# Test case 4: n = 5\nassert fib_space(5) == 3\n\n# Test case 5: n = 10\nassert fib_space(10) == 55"
    },
    {
        "title": "Fibonacci Sequence",
        "description": "Write a function named \"fib\" that takes an integer n as an argument and returns the nth number in the Fibonacci sequence.",
        "entry_point": "fib",
        "docstring": "def fib(n: int) -> int : \n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "assert fib(0) == 0\nassert fib(1) == 1\nassert fib(2) == 1\nassert fib(3) == 2\nassert fib(4) == 3\nassert fib(5) == 5\nassert fib(6) == 8\nassert fib(7) == 13\nassert fib(8) == 21\nassert fib(9) == 34\nassert fib(10) == 55"
    },
    {
        "title": "Longest Common Substring",
        "description": "Write a function named \"longestCommonSubstring\" that takes two strings as arguments and returns the longest common substring between them.",
        "entry_point": "longestCommonSubstring",
        "docstring": "def longestCommonSubstring(str1: str, str2: str) -> str:\n\"\"\"\nFind the longest common substring between two strings.\n\nParameters:\n- str1: The first string to compare (str)\n- str2: The second string to compare (str)\n\nReturns:\n- The longest common substring between str1 and str2 (str)\n\"\"\"",
        "unit_tests": "# Test case 1: Empty strings\nassert longestCommonSubstring(\"\", \"\") == \"\"\n\n# Test case 2: Single character strings\nassert longestCommonSubstring(\"a\", \"a\") == \"a\"\nassert longestCommonSubstring(\"a\", \"b\") == \"\"\n\n# Test case 3: Common substring with multiple occurrences\nassert longestCommonSubstring(\"hello\", \"world\") == \"\"\nassert longestCommonSubstring(\"hello\", \"olleh\") == \"ll\"\nassert longestCommonSubstring(\"ababab\", \"ababa\") == \"aba\"\n\n# Test case 4: Long strings with a common substring\nassert longestCommonSubstring(\"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\") == \"abcdefghijklmnopqrstuvwxyz\"\n\n# Test case 5: Strings with different lengths and no common substring\nassert longestCommonSubstring(\"abcd\", \"efgh\") == \"\""
    },
    {
        "title": "Minimum Path Sum",
        "description": "Write a function named \"minPathSum\" that takes a 2D array grid as an argument and returns the minimum sum of all paths from the top left corner to the bottom right corner.",
        "entry_point": "minPathSum",
        "docstring": "def minPathSum(grid: list of list of int) -> int : \n\"\"\"\nThis function takes a 2D array grid as an argument and returns the minimum sum of all paths from the top left corner to the bottom right corner.\n\nParameters:\n- grid (list of list of int): A 2D array representing the grid.\n\nReturn:\n- int: The minimum sum of all paths from the top left corner to the bottom right corner.\n\"\"\"",
        "unit_tests": "assert minPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 13\nassert minPathSum([[-2, 3, 4], [5, -1, 3], [1, 2, 0]]) == 1\nassert minPathSum([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) == 3\nassert minPathSum([[0, -1], [-1, 0]]) == 0\nassert minPathSum([[-1, -1], [1, 1]]) == -1"
    },
    {
        "title": "Partition Equal Subset Sum",
        "description": "Given a list of integers nums and a target sum target, determine if the list contains a partition of the sum into two subsets such that the sums of the two subsets are equal. Return True if such a partition exists and False otherwise.",
        "entry_point": "can_partition",
        "docstring": "def can_partition(nums: list[int], target: int) -> bool :\n\"\"\"\nDetermines if the list nums contains a partition of the sum target into two subsets such that the sums of the two subsets are equal.\n\nParameters:\n  nums (list): A list of integers.\n  target (int): The target sum.\n\nReturns:\n  bool: True if the list contains a partition of the target sum into two subsets with equal sums, False otherwise.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert can_partition([], 0) == True\n# Test case 2: List with single element\nassert can_partition([1], 1) == True\n# Test case 3: List with multiple elements and target sum\nassert can_partition([1, 2, 3, 4], 6) == True\n# Test case 4: List with multiple elements and target sum not achievable\nassert can_partition([1, 2, 3, 4], 7) == False\n# Test case 5: List with negative numbers\nassert can_partition([-1, 1, 2, 3], 2) == True"
    },
    {
        "title": "Maximum Subset Sum with Given Difference",
        "description": "Given a list of integers nums and an integer difference, return the maximum size of a subset of nums such that the sum of any two elements in the subset is equal to difference. Return 0 if such a subset does not exist.",
        "entry_point": "maximum_subset_sum_difference",
        "docstring": "def maximum_subset_sum_difference(nums: List[int], difference: int) -> int : \n\"\"\"\nReturns the maximum size of a subset of nums such that the sum of any two elements in the subset is equal to difference.\nIf no such subset exists, returns 0.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert maximum_subset_sum_difference([], 0) == 0\n# Test case 2: List with only one element\nassert maximum_subset_sum_difference([1], 1) == 1\n# Test case 3: List with elements that sum up to the difference\nassert maximum_subset_sum_difference([1, 2, 3], 4) == 2\n# Test case 4: List with elements that do not sum up to the difference\nassert maximum_subset_sum_difference([1, 2, 3], 5) == 0\n# Test case 5: List with negative elements\nassert maximum_subset_sum_difference([-1, 1], 0) == 1"
    },
    {
        "title": "Partition into Three Subsets",
        "description": "Given a list of integers nums, determine if it is possible to partition the list into three subsets such that the sums of all three subsets are equal. Return True if such a partition exists and False otherwise.",
        "entry_point": "partition_into_three_subsets",
        "docstring": "def partition_into_three_subsets(nums: List[int]) -> bool : \n\"\"\"\nDetermine if a given list of integers can be partitioned into three equal sum subsets.\n\nParameters:\n  nums (List[int]): The list of integers to partition.\n\nReturns:\n  bool: True if the list can be partitioned into three equal sum subsets, False otherwise.\n\"\"\"",
        "unit_tests": "# Test case 1: Empty list\nassert partition_into_three_subsets([]) == True\n# Test case 2: Single element list\nassert partition_into_three_subsets([1]) == False\n# Test case 3: List with three elements having the same value\nassert partition_into_three_subsets([1, 1, 1]) == True\n# Test case 4: List with three elements having different values\nassert partition_into_three_subsets([1, 2, 3]) == False\n# Test case 5: List with six elements having sum divisible by three\nassert partition_into_three_subsets([1, 2, 3, 4, 5, 6]) == True\n# Test case 6: List with six elements having sum not divisible by three\nassert partition_into_three_subsets([1, 2, 3, 4, 5, 7]) == False\n# Test case 7: List with duplicate elements\nassert partition_into_three_subsets([1, 2, 2, 3, 3, 3]) == True\n# Test case 8: List with negative integers\nassert partition_into_three_subsets([-1, -2, 1, 2]) == False\n# Test case 9: List with large integers\nassert partition_into_three_subsets([1000000001, 1000000001, 1000000001]) == False\n# Test case 10: List with all zeros\nassert partition_into_three_subsets([0, 0, 0]) == True"
    },
    {
        "title": "Exercise 1 Title",
        "description": "Exercise 1 description",
        "entry_point": "functionName1",
        "docstring": "def functionName1(param1: type, param2: type) -> type : \n\"\"\"DOCSTRING\"\"\"",
        "unit_tests": "# Test case 1: Test input with positive integers\nassert functionName1(5, 3) == 16\n# Test case 2: Test input with negative integers\nassert functionName1(-5, -3) == 25\n# Test case 3: Test input with zero\nassert functionName1(0, 0) == 0\n# Test case 4: Test input with float numbers\nassert functionName1(2.5, 3.2) == 11.249999999999996\n# Test case 5: Test input with strings\nassert functionName1(\"hello\", \"world\") == \"helloworldhelloworld\""
    },
    {
        "title": "Exercise 2 Title",
        "description": "Exercise 2 description",
        "entry_point": "functionName2",
        "docstring": "def functionName2(param1: type, param2: type) -> type :\n\"\"\"\nDOCSTRING\n\"\"\"",
        "unit_tests": "# Test case 1: Test input with positive numbers\nassert functionName2(5, 3) == 16\n# Test case 2: Test input with zero\nassert functionName2(0, 0) == 0\n# Test case 3: Test input with negative numbers\nassert functionName2(-2, -3) == 13\n# Test case 4: Test input with float numbers\nassert functionName2(2.5, 3.5) == 13.25\n# Test case 5: Test input with strings\nassert functionName2(\"hello\", \"world\") == \"helloworld\""
    },
    {
        "title": "Exercise 1 Title",
        "description": "Description of the exercise 1, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "mergeList",
        "docstring": "def mergeList(list1: List[int], list2: List[int]) -> List[int] :\n\"\"\"\nThis function takes two lists of integers as arguments and returns a new list which is the merge of the two input lists.\nThe merge is performed in ascending order.\nThe function takes two lists as arguments:\n- list1: List[int]\n- list2: List[int]\nThe function returns a new list:\n- List[int]\n\"\"\"",
        "unit_tests": "assert mergeList([], []) == []\nassert mergeList([1], []) == [1]\nassert mergeList([1], [2]) == [1, 2]\nassert mergeList([1, 2], []) == [1, 2]\nassert mergeList([1, 2], [3]) == [1, 2, 3]\nassert mergeList([1, 2], [1]) == [1, 1, 2]\nassert mergeList([], [1, 2]) == [1, 2]\nassert mergeList([1, 2, 3], [4, 5]) == [1, 2, 3, 4, 5]"
    },
    {
        "title": "Exercise 2 Title",
        "description": "Description of the exercise 2, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "reverseList",
        "docstring": "def reverseList(lst: list) -> list :\n\"\"\"\nThis function takes a list as an argument and returns a new list with the elements reversed.\nThe function does not modify the original list.\n\"\"\"",
        "unit_tests": "# Test 1: Test empty list\nassert reverseList([]) == []\n\n# Test 2: Test list with one element\nassert reverseList([1]) == [1]\n\n# Test 3: Test list with multiple elements\nassert reverseList([1, 2, 3]) == [3, 2, 1]\n\n# Test 4: Test list with negative numbers\nassert reverseList([-1, -2, -3]) == [3, 2, 1]\n\n# Test 5: Test list with strings\nassert reverseList([\"hello\"]) == [\"hello\"]\nassert reverseList([\"hello\", \"world\"]) == [\"world\", \"hello\"]"
    },
    {
        "title": "Exercise 3 Title",
        "description": "Description of the exercise 3, containing the problem statement and constraints, the arguments and their types, and the return type. The description should be the docstring of the function to be implemented.",
        "entry_point": "isPalindrome",
        "docstring": "def isPalindrome(string: str) -> bool :\n\"\"\"\nDetermines if the given string is a palindrome.\n\nParameters:\n    string: str - The input string to be checked for palindrome property.\n\nReturn Type:\n    bool - Returns True if the string is a palindrome and False otherwise.\n\"\"\"",
        "unit_tests": "# Test 1: Empty string is a palindrome\nassert isPalindrome(\"\") == True\n\n# Test 2: Palindrome string\nassert isPalindrome(\"racecar\") == True\n\n# Test 3: Non-palindrome string with different characters\nassert isPalindrome(\"hello\") == False\n\n# Test 4: Non-palindrome string with same characters but in different order\nassert isPalindrome(\"level\") == False\n\n# Test 5: Palindrome string with special characters\nassert isPalindrome(\"A man, a plan, a canal: Panama\") == True"
    }
]